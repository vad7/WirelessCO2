
WirelessCO2Sensor.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000dfe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  00000dfe  00000e92  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000003d  00800062  00800062  00000e94  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e94  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000100  00000000  00000000  00000ec4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000159e  00000000  00000000  00000fc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003b1  00000000  00000000  00002562  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000007b1  00000000  00000000  00002913  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000368  00000000  00000000  000030c4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000005f6  00000000  00000000  0000342c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000010dc  00000000  00000000  00003a22  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000188  00000000  00000000  00004afe  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	17 c0       	rjmp	.+46     	; 0x30 <__ctors_end>
   2:	31 c0       	rjmp	.+98     	; 0x66 <__bad_interrupt>
   4:	ce c1       	rjmp	.+924    	; 0x3a2 <__vector_2>
   6:	62 c2       	rjmp	.+1220   	; 0x4cc <__vector_3>
   8:	42 c1       	rjmp	.+644    	; 0x28e <__vector_4>
   a:	2d c0       	rjmp	.+90     	; 0x66 <__bad_interrupt>
   c:	2c c0       	rjmp	.+88     	; 0x66 <__bad_interrupt>
   e:	2b c0       	rjmp	.+86     	; 0x66 <__bad_interrupt>
  10:	f2 c1       	rjmp	.+996    	; 0x3f6 <__vector_8>
  12:	29 c0       	rjmp	.+82     	; 0x66 <__bad_interrupt>
  14:	28 c0       	rjmp	.+80     	; 0x66 <__bad_interrupt>
  16:	09 c2       	rjmp	.+1042   	; 0x42a <__vector_11>
  18:	26 c0       	rjmp	.+76     	; 0x66 <__bad_interrupt>
  1a:	aa c1       	rjmp	.+852    	; 0x370 <__vector_13>
  1c:	24 c0       	rjmp	.+72     	; 0x66 <__bad_interrupt>
  1e:	23 c0       	rjmp	.+70     	; 0x66 <__bad_interrupt>
  20:	22 c0       	rjmp	.+68     	; 0x66 <__bad_interrupt>

00000022 <NRF24_BASE_ADDR>:
  22:	c8 c8                                               ..

00000024 <NRF24_INIT_DATA>:
  24:	23 01 24 77 26 07 21 01 22 01 31 04                 #.$w&.!.".1.

00000030 <__ctors_end>:
  30:	11 24       	eor	r1, r1
  32:	1f be       	out	0x3f, r1	; 63
  34:	cf e5       	ldi	r28, 0x5F	; 95
  36:	d1 e0       	ldi	r29, 0x01	; 1
  38:	de bf       	out	0x3e, r29	; 62
  3a:	cd bf       	out	0x3d, r28	; 61

0000003c <__do_copy_data>:
  3c:	10 e0       	ldi	r17, 0x00	; 0
  3e:	a0 e6       	ldi	r26, 0x60	; 96
  40:	b0 e0       	ldi	r27, 0x00	; 0
  42:	ee ef       	ldi	r30, 0xFE	; 254
  44:	fd e0       	ldi	r31, 0x0D	; 13
  46:	02 c0       	rjmp	.+4      	; 0x4c <__SREG__+0xd>
  48:	05 90       	lpm	r0, Z+
  4a:	0d 92       	st	X+, r0
  4c:	a2 36       	cpi	r26, 0x62	; 98
  4e:	b1 07       	cpc	r27, r17
  50:	d9 f7       	brne	.-10     	; 0x48 <__SREG__+0x9>

00000052 <__do_clear_bss>:
  52:	20 e0       	ldi	r18, 0x00	; 0
  54:	a2 e6       	ldi	r26, 0x62	; 98
  56:	b0 e0       	ldi	r27, 0x00	; 0
  58:	01 c0       	rjmp	.+2      	; 0x5c <.do_clear_bss_start>

0000005a <.do_clear_bss_loop>:
  5a:	1d 92       	st	X+, r1

0000005c <.do_clear_bss_start>:
  5c:	af 39       	cpi	r26, 0x9F	; 159
  5e:	b2 07       	cpc	r27, r18
  60:	e1 f7       	brne	.-8      	; 0x5a <.do_clear_bss_loop>
  62:	d4 d2       	rcall	.+1448   	; 0x60c <main>
  64:	ca c6       	rjmp	.+3476   	; 0xdfa <_exit>

00000066 <__bad_interrupt>:
  66:	cc cf       	rjmp	.-104    	; 0x0 <__vectors>

00000068 <Delay10us>:
   uint8_t Flags; // // Mask: 0x80 - Setup command, 0x01 - Lowlight
} __attribute__ ((packed)) send_data;

#if(1)
void Delay10us(uint8_t ms) {
	while(ms-- > 0) _delay_us(10); //wdt_reset();
  68:	88 23       	and	r24, r24
  6a:	31 f0       	breq	.+12     	; 0x78 <Delay10us+0x10>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  6c:	9b e1       	ldi	r25, 0x1B	; 27
  6e:	9a 95       	dec	r25
  70:	f1 f7       	brne	.-4      	; 0x6e <Delay10us+0x6>
  72:	00 00       	nop
  74:	81 50       	subi	r24, 0x01	; 1
  76:	f8 cf       	rjmp	.-16     	; 0x68 <Delay10us>
}
  78:	08 95       	ret

0000007a <Delay100ms>:
	while(ms-- > 0) { 
		_delay_ms(1); //wdt_reset(); 
	}
}
void Delay100ms(unsigned int ms) {
	while(ms-- > 0) { 
  7a:	00 97       	sbiw	r24, 0x00	; 0
  7c:	59 f0       	breq	.+22     	; 0x94 <Delay100ms+0x1a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  7e:	2f ef       	ldi	r18, 0xFF	; 255
  80:	3f e7       	ldi	r19, 0x7F	; 127
  82:	42 e0       	ldi	r20, 0x02	; 2
  84:	21 50       	subi	r18, 0x01	; 1
  86:	30 40       	sbci	r19, 0x00	; 0
  88:	40 40       	sbci	r20, 0x00	; 0
  8a:	e1 f7       	brne	.-8      	; 0x84 <Delay100ms+0xa>
  8c:	00 c0       	rjmp	.+0      	; 0x8e <Delay100ms+0x14>
  8e:	00 00       	nop
  90:	01 97       	sbiw	r24, 0x01	; 1
  92:	f3 cf       	rjmp	.-26     	; 0x7a <Delay100ms>
		_delay_ms(100); //wdt_reset();
	}
}
  94:	08 95       	ret

00000096 <FlashLED>:

void FlashLED(uint8_t num, uint8_t toff, uint8_t ton) {
  96:	ff 92       	push	r15
  98:	0f 93       	push	r16
  9a:	1f 93       	push	r17
  9c:	cf 93       	push	r28
  9e:	df 93       	push	r29
	while (num-- > 0) {
  a0:	f8 2e       	mov	r15, r24
		LED1_OFF;
		Delay100ms(toff);
  a2:	06 2f       	mov	r16, r22
  a4:	10 e0       	ldi	r17, 0x00	; 0
		LED1_ON;
		Delay100ms(ton);
  a6:	c4 2f       	mov	r28, r20
  a8:	d0 e0       	ldi	r29, 0x00	; 0
	}
}

void FlashLED(uint8_t num, uint8_t toff, uint8_t ton) {
	while (num-- > 0) {
		LED1_OFF;
  aa:	d9 98       	cbi	0x1b, 1	; 27
		_delay_ms(100); //wdt_reset();
	}
}

void FlashLED(uint8_t num, uint8_t toff, uint8_t ton) {
	while (num-- > 0) {
  ac:	ff 20       	and	r15, r15
  ae:	39 f0       	breq	.+14     	; 0xbe <FlashLED+0x28>
		LED1_OFF;
		Delay100ms(toff);
  b0:	c8 01       	movw	r24, r16
  b2:	e3 df       	rcall	.-58     	; 0x7a <Delay100ms>
		LED1_ON;
  b4:	d9 9a       	sbi	0x1b, 1	; 27
		Delay100ms(ton);
  b6:	ce 01       	movw	r24, r28
  b8:	e0 df       	rcall	.-64     	; 0x7a <Delay100ms>
  ba:	fa 94       	dec	r15
  bc:	f6 cf       	rjmp	.-20     	; 0xaa <FlashLED+0x14>
	}
	LED1_OFF;
}
  be:	df 91       	pop	r29
  c0:	cf 91       	pop	r28
  c2:	1f 91       	pop	r17
  c4:	0f 91       	pop	r16
  c6:	ff 90       	pop	r15
  c8:	08 95       	ret

000000ca <EEPROM_read>:
	Delay100ms(20);
}

uint8_t EEPROM_read(uint8_t ucAddress) // ATtiny24A/44A only!
{
	while(EECR & (1<<EEPE)) ; // EEWE
  ca:	e1 99       	sbic	0x1c, 1	; 28
  cc:	fe cf       	rjmp	.-4      	; 0xca <EEPROM_read>
	EEAR = ucAddress;
  ce:	90 e0       	ldi	r25, 0x00	; 0
  d0:	9f bb       	out	0x1f, r25	; 31
  d2:	8e bb       	out	0x1e, r24	; 30
	EECR |= (1<<EERE);
  d4:	e0 9a       	sbi	0x1c, 0	; 28
	return EEDR;
  d6:	8d b3       	in	r24, 0x1d	; 29
}
  d8:	08 95       	ret

000000da <EEPROM_write>:
void EEPROM_write(uint8_t ucAddress, uint8_t ucData) // ATtiny24A/44A only!
{
	while(EECR & (1<<EEPE)) ; // EEWE
  da:	e1 99       	sbic	0x1c, 1	; 28
  dc:	fe cf       	rjmp	.-4      	; 0xda <EEPROM_write>
	cli();
  de:	f8 94       	cli
	EECR = (0<<EEPM1)|(0<<EEPM0);
  e0:	1c ba       	out	0x1c, r1	; 28
	EEAR = ucAddress;
  e2:	90 e0       	ldi	r25, 0x00	; 0
  e4:	9f bb       	out	0x1f, r25	; 31
  e6:	8e bb       	out	0x1e, r24	; 30
	EEDR = ucData;
  e8:	6d bb       	out	0x1d, r22	; 29
	EECR |= (1<<EEMPE); //(1<<EEMWE);
  ea:	e2 9a       	sbi	0x1c, 2	; 28
	EECR |= (1<<EEPE); //(1<<EEWE);
  ec:	e1 9a       	sbi	0x1c, 1	; 28
	sei();
  ee:	78 94       	sei
  f0:	08 95       	ret

000000f2 <SPI_WriteReadByte>:
	NRF24_CMD_W_REGISTER | NRF24_REG_RX_PW_P0,	NRF24_PAYLOAD_LEN
};
const uint8_t NRF24_BASE_ADDR[] PROGMEM = { 0xC8, 0xC8 }; // Address MSBs: 2..3

uint8_t SPI_WriteReadByte(uint8_t data) {
	USIDR = data;
  f2:	8f b9       	out	0x0f, r24	; 15
	USISR = (1<<USIOIF); // clear overflow flag
  f4:	80 e4       	ldi	r24, 0x40	; 64
  f6:	8e b9       	out	0x0e, r24	; 14
	do {
		USICR = (1<<USIWM0) | (1<<USICS1) | (1<<USICLK) | (1<<USITC);
  f8:	8b e1       	ldi	r24, 0x1B	; 27
  fa:	8d b9       	out	0x0d, r24	; 13
	} while((USISR & (1<<USIOIF)) == 0);
  fc:	76 9b       	sbis	0x0e, 6	; 14
  fe:	fd cf       	rjmp	.-6      	; 0xfa <SPI_WriteReadByte+0x8>
	return USIDR;
 100:	8f b1       	in	r24, 0x0f	; 15
}
 102:	08 95       	ret

00000104 <NRF24_ReadArray>:
	NRF24_SET_CSN_HI;
	return result;
}

void NRF24_ReadArray(uint8_t cmd, uint8_t *array, uint8_t len)
{
 104:	ef 92       	push	r14
 106:	ff 92       	push	r15
 108:	1f 93       	push	r17
 10a:	cf 93       	push	r28
 10c:	df 93       	push	r29
 10e:	00 d0       	rcall	.+0      	; 0x110 <NRF24_ReadArray+0xc>
 110:	cd b7       	in	r28, 0x3d	; 61
 112:	de b7       	in	r29, 0x3e	; 62
 114:	14 2f       	mov	r17, r20
	NRF24_SET_CSN_LOW;
 116:	db 98       	cbi	0x1b, 3	; 27
	SPI_WriteReadByte(cmd);
 118:	69 83       	std	Y+1, r22	; 0x01
 11a:	7a 83       	std	Y+2, r23	; 0x02
 11c:	ea df       	rcall	.-44     	; 0xf2 <SPI_WriteReadByte>
	while(len-- > 0) *array++ = SPI_WriteReadByte(NRF24_CMD_NOP);
 11e:	69 81       	ldd	r22, Y+1	; 0x01
 120:	e6 2e       	mov	r14, r22
 122:	7a 81       	ldd	r23, Y+2	; 0x02
 124:	f7 2e       	mov	r15, r23
 126:	16 0f       	add	r17, r22
 128:	1e 15       	cp	r17, r14
 12a:	31 f0       	breq	.+12     	; 0x138 <NRF24_ReadArray+0x34>
 12c:	8f ef       	ldi	r24, 0xFF	; 255
 12e:	e1 df       	rcall	.-62     	; 0xf2 <SPI_WriteReadByte>
 130:	f7 01       	movw	r30, r14
 132:	81 93       	st	Z+, r24
 134:	7f 01       	movw	r14, r30
 136:	f8 cf       	rjmp	.-16     	; 0x128 <NRF24_ReadArray+0x24>
	NRF24_SET_CSN_HI;
 138:	db 9a       	sbi	0x1b, 3	; 27
}
 13a:	0f 90       	pop	r0
 13c:	0f 90       	pop	r0
 13e:	df 91       	pop	r29
 140:	cf 91       	pop	r28
 142:	1f 91       	pop	r17
 144:	ff 90       	pop	r15
 146:	ef 90       	pop	r14
 148:	08 95       	ret

0000014a <NRF24_WriteByte>:

void NRF24_WriteByte(uint8_t cmd, uint8_t value)
{
 14a:	cf 93       	push	r28
 14c:	df 93       	push	r29
 14e:	1f 92       	push	r1
 150:	cd b7       	in	r28, 0x3d	; 61
 152:	de b7       	in	r29, 0x3e	; 62
	NRF24_SET_CSN_LOW;
 154:	db 98       	cbi	0x1b, 3	; 27
	SPI_WriteReadByte(cmd);
 156:	69 83       	std	Y+1, r22	; 0x01
 158:	cc df       	rcall	.-104    	; 0xf2 <SPI_WriteReadByte>
	SPI_WriteReadByte(value);
 15a:	69 81       	ldd	r22, Y+1	; 0x01
 15c:	86 2f       	mov	r24, r22
 15e:	c9 df       	rcall	.-110    	; 0xf2 <SPI_WriteReadByte>
	NRF24_SET_CSN_HI;
 160:	db 9a       	sbi	0x1b, 3	; 27
}
 162:	0f 90       	pop	r0
 164:	df 91       	pop	r29
 166:	cf 91       	pop	r28
 168:	08 95       	ret

0000016a <NRF24_WriteArray>:

void NRF24_WriteArray(int8_t cmd, uint8_t *array, uint8_t len)
{
 16a:	ef 92       	push	r14
 16c:	ff 92       	push	r15
 16e:	1f 93       	push	r17
 170:	cf 93       	push	r28
 172:	df 93       	push	r29
 174:	00 d0       	rcall	.+0      	; 0x176 <NRF24_WriteArray+0xc>
 176:	cd b7       	in	r28, 0x3d	; 61
 178:	de b7       	in	r29, 0x3e	; 62
 17a:	14 2f       	mov	r17, r20
	NRF24_SET_CSN_LOW;
 17c:	db 98       	cbi	0x1b, 3	; 27
	SPI_WriteReadByte(cmd);
 17e:	69 83       	std	Y+1, r22	; 0x01
 180:	7a 83       	std	Y+2, r23	; 0x02
 182:	b7 df       	rcall	.-146    	; 0xf2 <SPI_WriteReadByte>
	while(len-- > 0) SPI_WriteReadByte(*array++);
 184:	69 81       	ldd	r22, Y+1	; 0x01
 186:	e6 2e       	mov	r14, r22
 188:	7a 81       	ldd	r23, Y+2	; 0x02
 18a:	f7 2e       	mov	r15, r23
 18c:	16 0f       	add	r17, r22
 18e:	1e 15       	cp	r17, r14
 190:	29 f0       	breq	.+10     	; 0x19c <NRF24_WriteArray+0x32>
 192:	f7 01       	movw	r30, r14
 194:	81 91       	ld	r24, Z+
 196:	7f 01       	movw	r14, r30
 198:	ac df       	rcall	.-168    	; 0xf2 <SPI_WriteReadByte>
 19a:	f9 cf       	rjmp	.-14     	; 0x18e <NRF24_WriteArray+0x24>
	NRF24_SET_CSN_HI;
 19c:	db 9a       	sbi	0x1b, 3	; 27
}
 19e:	0f 90       	pop	r0
 1a0:	0f 90       	pop	r0
 1a2:	df 91       	pop	r29
 1a4:	cf 91       	pop	r28
 1a6:	1f 91       	pop	r17
 1a8:	ff 90       	pop	r15
 1aa:	ef 90       	pop	r14
 1ac:	08 95       	ret

000001ae <NRF24_SendCommand>:

uint8_t NRF24_SendCommand(uint8_t cmd) // Send command & receive status
{
	NRF24_SET_CSN_LOW;
 1ae:	db 98       	cbi	0x1b, 3	; 27
	uint8_t result = SPI_WriteReadByte(cmd);
 1b0:	a0 df       	rcall	.-192    	; 0xf2 <SPI_WriteReadByte>
	NRF24_SET_CSN_HI;
 1b2:	db 9a       	sbi	0x1b, 3	; 27
	return result;
}
 1b4:	08 95       	ret

000001b6 <NRF24_SetMode>:

void NRF24_SetMode(uint8_t mode) // Set mode in CONFIG reg
{
 1b6:	cf 93       	push	r28
 1b8:	c8 2f       	mov	r28, r24
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_CONFIG, NRF24_CONFIG | (1<<NRF24_BIT_PWR_UP) | mode);
 1ba:	68 2f       	mov	r22, r24
 1bc:	6e 67       	ori	r22, 0x7E	; 126
 1be:	80 e2       	ldi	r24, 0x20	; 32
 1c0:	c4 df       	rcall	.-120    	; 0x14a <NRF24_WriteByte>
	if(mode & NRF24_ReceiveMode) { // Receive mode
 1c2:	c0 ff       	sbrs	r28, 0
 1c4:	04 c0       	rjmp	.+8      	; 0x1ce <NRF24_SetMode+0x18>
		//NRF24_SendCommand(NRF24_CMD_FLUSH_RX);
		NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_STATUS, (1<<NRF24_BIT_RX_DR) | (1<<NRF24_BIT_TX_DS) | (1<<NRF24_BIT_MAX_RT)); // clear status
 1c6:	60 e7       	ldi	r22, 0x70	; 112
 1c8:	87 e2       	ldi	r24, 0x27	; 39
 1ca:	bf df       	rcall	.-130    	; 0x14a <NRF24_WriteByte>
		NRF24_SET_CE_HI; // start receiving
 1cc:	da 9a       	sbi	0x1b, 2	; 27
	}
}
 1ce:	cf 91       	pop	r28
 1d0:	08 95       	ret

000001d2 <NRF24_Transmit>:
	}
	return pipe;
}

uint8_t NRF24_Transmit(uint8_t *payload) // Transmit payload, return 0 if success, 1 - max retransmit count reached, 2 - module not response.
{
 1d2:	cf 93       	push	r28
 1d4:	df 93       	push	r29
 1d6:	ec 01       	movw	r28, r24
	NRF24_SET_CE_LOW;
 1d8:	da 98       	cbi	0x1b, 2	; 27
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_STATUS, (1<<NRF24_BIT_RX_DR) | (1<<NRF24_BIT_TX_DS) | (1<<NRF24_BIT_MAX_RT)); // clear status
 1da:	60 e7       	ldi	r22, 0x70	; 112
 1dc:	87 e2       	ldi	r24, 0x27	; 39
 1de:	b5 df       	rcall	.-150    	; 0x14a <NRF24_WriteByte>
	NRF24_SendCommand(NRF24_CMD_FLUSH_TX);
 1e0:	81 ee       	ldi	r24, 0xE1	; 225
 1e2:	e5 df       	rcall	.-54     	; 0x1ae <NRF24_SendCommand>
	NRF24_WriteArray(NRF24_CMD_W_TX_PAYLOAD, payload, NRF24_PAYLOAD_LEN);
 1e4:	44 e0       	ldi	r20, 0x04	; 4
 1e6:	be 01       	movw	r22, r28
 1e8:	80 ea       	ldi	r24, 0xA0	; 160
 1ea:	bf df       	rcall	.-130    	; 0x16a <NRF24_WriteArray>
	NRF24_SET_CE_HI; // Start transmission
 1ec:	da 9a       	sbi	0x1b, 2	; 27
 1ee:	cf ef       	ldi	r28, 0xFF	; 255
	uint8_t st = 0, i;
	for(i = 1; i != 0; i++)
	{
		Delay10us(20);
 1f0:	84 e1       	ldi	r24, 0x14	; 20
 1f2:	3a df       	rcall	.-396    	; 0x68 <Delay10us>
		st = NRF24_SendCommand(NRF24_CMD_NOP);
 1f4:	8f ef       	ldi	r24, 0xFF	; 255
 1f6:	db df       	rcall	.-74     	; 0x1ae <NRF24_SendCommand>
		if((st & ((1<<NRF24_BIT_MAX_RT) | (1<<NRF24_BIT_TX_DS)))) break; // stop if sent or max retransmit reached
 1f8:	98 2f       	mov	r25, r24
 1fa:	90 73       	andi	r25, 0x30	; 48
 1fc:	21 f4       	brne	.+8      	; 0x206 <NRF24_Transmit+0x34>
 1fe:	c1 50       	subi	r28, 0x01	; 1
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_STATUS, (1<<NRF24_BIT_RX_DR) | (1<<NRF24_BIT_TX_DS) | (1<<NRF24_BIT_MAX_RT)); // clear status
	NRF24_SendCommand(NRF24_CMD_FLUSH_TX);
	NRF24_WriteArray(NRF24_CMD_W_TX_PAYLOAD, payload, NRF24_PAYLOAD_LEN);
	NRF24_SET_CE_HI; // Start transmission
	uint8_t st = 0, i;
	for(i = 1; i != 0; i++)
 200:	b9 f7       	brne	.-18     	; 0x1f0 <NRF24_Transmit+0x1e>
	{
		Delay10us(20);
		st = NRF24_SendCommand(NRF24_CMD_NOP);
		if((st & ((1<<NRF24_BIT_MAX_RT) | (1<<NRF24_BIT_TX_DS)))) break; // stop if sent or max retransmit reached
	}
	return i == 0 ? 2 : !(st & (1<<NRF24_BIT_TX_DS));
 202:	82 e0       	ldi	r24, 0x02	; 2
 204:	05 c0       	rjmp	.+10     	; 0x210 <NRF24_Transmit+0x3e>
 206:	85 fb       	bst	r24, 5
 208:	88 27       	eor	r24, r24
 20a:	80 f9       	bld	r24, 0
 20c:	91 e0       	ldi	r25, 0x01	; 1
 20e:	89 27       	eor	r24, r25
}
 210:	df 91       	pop	r29
 212:	cf 91       	pop	r28
 214:	08 95       	ret

00000216 <NRF24_SetAddresses>:

uint8_t NRF24_SetAddresses(uint8_t addr_LSB) // Set addresses: NRF24_BASE_ADDR + addr_LSB, return 1 if success
{
 216:	cf 93       	push	r28
 218:	c8 2f       	mov	r28, r24
	NRF24_Buffer[0] = addr_LSB;
 21a:	80 93 88 00 	sts	0x0088, r24
	memcpy_P(NRF24_Buffer + 1, NRF24_BASE_ADDR, sizeof(NRF24_BASE_ADDR)/sizeof(NRF24_BASE_ADDR[0]));
 21e:	42 e0       	ldi	r20, 0x02	; 2
 220:	50 e0       	ldi	r21, 0x00	; 0
 222:	62 e2       	ldi	r22, 0x22	; 34
 224:	70 e0       	ldi	r23, 0x00	; 0
 226:	89 e8       	ldi	r24, 0x89	; 137
 228:	90 e0       	ldi	r25, 0x00	; 0
 22a:	de d5       	rcall	.+3004   	; 0xde8 <memcpy_P>
	NRF24_WriteArray(NRF24_CMD_W_REGISTER | NRF24_REG_RX_ADDR_P0, NRF24_Buffer, NRF24_ADDRESS_LEN);
 22c:	43 e0       	ldi	r20, 0x03	; 3
 22e:	68 e8       	ldi	r22, 0x88	; 136
 230:	70 e0       	ldi	r23, 0x00	; 0
 232:	8a e2       	ldi	r24, 0x2A	; 42
 234:	9a df       	rcall	.-204    	; 0x16a <NRF24_WriteArray>
	NRF24_WriteArray(NRF24_CMD_W_REGISTER | NRF24_REG_TX_ADDR, NRF24_Buffer, NRF24_ADDRESS_LEN);
 236:	43 e0       	ldi	r20, 0x03	; 3
 238:	68 e8       	ldi	r22, 0x88	; 136
 23a:	70 e0       	ldi	r23, 0x00	; 0
 23c:	80 e3       	ldi	r24, 0x30	; 48
 23e:	95 df       	rcall	.-214    	; 0x16a <NRF24_WriteArray>
	NRF24_ReadArray(NRF24_CMD_R_REGISTER | NRF24_REG_TX_ADDR, NRF24_Buffer, NRF24_ADDRESS_LEN);
 240:	43 e0       	ldi	r20, 0x03	; 3
 242:	68 e8       	ldi	r22, 0x88	; 136
 244:	70 e0       	ldi	r23, 0x00	; 0
 246:	80 e1       	ldi	r24, 0x10	; 16
 248:	5d df       	rcall	.-326    	; 0x104 <NRF24_ReadArray>
	return NRF24_Buffer[0] == addr_LSB;
 24a:	81 e0       	ldi	r24, 0x01	; 1
 24c:	90 91 88 00 	lds	r25, 0x0088
 250:	9c 13       	cpse	r25, r28
 252:	80 e0       	ldi	r24, 0x00	; 0
}
 254:	cf 91       	pop	r28
 256:	08 95       	ret

00000258 <NRF24_Powerdown>:

void NRF24_Powerdown(void)
{
	NRF24_SET_CE_LOW;
 258:	da 98       	cbi	0x1b, 2	; 27
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_CONFIG, NRF24_CONFIG); // Power down
 25a:	6c e7       	ldi	r22, 0x7C	; 124
 25c:	80 e2       	ldi	r24, 0x20	; 32
 25e:	75 cf       	rjmp	.-278    	; 0x14a <NRF24_WriteByte>

00000260 <NRF24_init>:
}

void NRF24_init(uint8_t channel) // After init transmit must be delayed
{
 260:	1f 93       	push	r17
 262:	cf 93       	push	r28
 264:	df 93       	push	r29
 266:	18 2f       	mov	r17, r24
	NRF24_SET_CSN_HI;
 268:	db 9a       	sbi	0x1b, 3	; 27
 26a:	c4 e2       	ldi	r28, 0x24	; 36
 26c:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i = 0, c, v;
	do {
		c = pgm_read_byte(&NRF24_INIT_DATA[i++]);
 26e:	fe 01       	movw	r30, r28
 270:	84 91       	lpm	r24, Z
 272:	31 96       	adiw	r30, 0x01	; 1
		v = pgm_read_byte(&NRF24_INIT_DATA[i++]);
 274:	64 91       	lpm	r22, Z
		NRF24_WriteByte(c, v); 
 276:	69 df       	rcall	.-302    	; 0x14a <NRF24_WriteByte>
 278:	22 96       	adiw	r28, 0x02	; 2
	} while(i < sizeof(NRF24_INIT_DATA));
 27a:	f0 e0       	ldi	r31, 0x00	; 0
 27c:	c0 33       	cpi	r28, 0x30	; 48
 27e:	df 07       	cpc	r29, r31
 280:	b1 f7       	brne	.-20     	; 0x26e <NRF24_init+0xe>
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH,	channel);
 282:	61 2f       	mov	r22, r17
 284:	85 e2       	ldi	r24, 0x25	; 37
}
 286:	df 91       	pop	r29
 288:	cf 91       	pop	r28
 28a:	1f 91       	pop	r17
	do {
		c = pgm_read_byte(&NRF24_INIT_DATA[i++]);
		v = pgm_read_byte(&NRF24_INIT_DATA[i++]);
		NRF24_WriteByte(c, v); 
	} while(i < sizeof(NRF24_INIT_DATA));
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH,	channel);
 28c:	5e cf       	rjmp	.-324    	; 0x14a <NRF24_WriteByte>

0000028e <__vector_4>:

#define SETUP_WATCHDOG WDTCSR = (1<<WDCE) | (1<<WDE); WDTCSR = (1<<WDE) | (1<<WDIE) | (0<<WDP3) | (0<<WDP2) | (1<<WDP1) | (1<<WDP0);	//  Watchdog 0.125 s
uint8_t LED_WarningOnCnt = 0, LED_WarningOffCnt = 0, LED_Warning_WorkLong = 0, LED_Warning_WorkShort = 0, LED_Warning_NoRepeat = 0;

ISR(WATCHDOG_vect)
{
 28e:	1f 92       	push	r1
 290:	0f 92       	push	r0
 292:	0f b6       	in	r0, 0x3f	; 63
 294:	0f 92       	push	r0
 296:	11 24       	eor	r1, r1
 298:	8f 93       	push	r24
 29a:	9f 93       	push	r25
	SETUP_WATCHDOG;
 29c:	88 e1       	ldi	r24, 0x18	; 24
 29e:	81 bd       	out	0x21, r24	; 33
 2a0:	8b e4       	ldi	r24, 0x4B	; 75
 2a2:	81 bd       	out	0x21, r24	; 33
	if(Timer) Timer--;
 2a4:	80 91 61 00 	lds	r24, 0x0061
 2a8:	88 23       	and	r24, r24
 2aa:	29 f0       	breq	.+10     	; 0x2b6 <__vector_4+0x28>
 2ac:	80 91 61 00 	lds	r24, 0x0061
 2b0:	81 50       	subi	r24, 0x01	; 1
 2b2:	80 93 61 00 	sts	0x0061, r24
	if(KeyOkTimeout) KeyOkTimeout--;
 2b6:	80 91 6f 00 	lds	r24, 0x006F
 2ba:	88 23       	and	r24, r24
 2bc:	19 f0       	breq	.+6      	; 0x2c4 <__vector_4+0x36>
 2be:	81 50       	subi	r24, 0x01	; 1
 2c0:	80 93 6f 00 	sts	0x006F, r24
	// LED_Warning: 0xF0 mask - Number of long flashes, 0x0F mask - Number of short flashes
	if(LED_WarningOnCnt) {
 2c4:	80 91 67 00 	lds	r24, 0x0067
 2c8:	88 23       	and	r24, r24
 2ca:	39 f0       	breq	.+14     	; 0x2da <__vector_4+0x4c>
		LED1_ON;
 2cc:	d9 9a       	sbi	0x1b, 1	; 27
		LED_WarningOnCnt--;
 2ce:	80 91 67 00 	lds	r24, 0x0067
 2d2:	81 50       	subi	r24, 0x01	; 1
 2d4:	80 93 67 00 	sts	0x0067, r24
 2d8:	44 c0       	rjmp	.+136    	; 0x362 <__vector_4+0xd4>
	} else if(LED_WarningOffCnt) {	
 2da:	80 91 66 00 	lds	r24, 0x0066
 2de:	88 23       	and	r24, r24
 2e0:	29 f0       	breq	.+10     	; 0x2ec <__vector_4+0x5e>
		LED1_OFF;
 2e2:	d9 98       	cbi	0x1b, 1	; 27
		LED_WarningOffCnt--;
 2e4:	80 91 66 00 	lds	r24, 0x0066
 2e8:	81 50       	subi	r24, 0x01	; 1
 2ea:	0f c0       	rjmp	.+30     	; 0x30a <__vector_4+0x7c>
	} else if(LED_Warning_WorkLong) { // long flashes
 2ec:	80 91 65 00 	lds	r24, 0x0065
 2f0:	88 23       	and	r24, r24
 2f2:	71 f0       	breq	.+28     	; 0x310 <__vector_4+0x82>
		LED_Warning_WorkLong--;
 2f4:	81 50       	subi	r24, 0x01	; 1
 2f6:	80 93 65 00 	sts	0x0065, r24
		LED_WarningOnCnt = 10;
 2fa:	9a e0       	ldi	r25, 0x0A	; 10
 2fc:	90 93 67 00 	sts	0x0067, r25
		if(LED_Warning_WorkLong == 0) {
 300:	81 11       	cpse	r24, r1
 302:	02 c0       	rjmp	.+4      	; 0x308 <__vector_4+0x7a>
			LED_WarningOffCnt = 6;
 304:	86 e0       	ldi	r24, 0x06	; 6
 306:	0e c0       	rjmp	.+28     	; 0x324 <__vector_4+0x96>
			goto xSetPause;
		} else LED_WarningOffCnt = 3;
 308:	83 e0       	ldi	r24, 0x03	; 3
 30a:	80 93 66 00 	sts	0x0066, r24
 30e:	29 c0       	rjmp	.+82     	; 0x362 <__vector_4+0xd4>
	} else if(LED_Warning_WorkShort) { // short flashes
 310:	80 91 64 00 	lds	r24, 0x0064
 314:	88 23       	and	r24, r24
 316:	71 f0       	breq	.+28     	; 0x334 <__vector_4+0xa6>
		LED_Warning_WorkShort--;
 318:	81 50       	subi	r24, 0x01	; 1
 31a:	80 93 64 00 	sts	0x0064, r24
		LED_WarningOnCnt = 2;
 31e:	82 e0       	ldi	r24, 0x02	; 2
 320:	80 93 67 00 	sts	0x0067, r24
		LED_WarningOffCnt = 2;
 324:	80 93 66 00 	sts	0x0066, r24
xSetPause:	if(LED_Warning_WorkShort == 0) LED_WarningOffCnt = 20;
 328:	80 91 64 00 	lds	r24, 0x0064
 32c:	81 11       	cpse	r24, r1
 32e:	19 c0       	rjmp	.+50     	; 0x362 <__vector_4+0xd4>
 330:	84 e1       	ldi	r24, 0x14	; 20
 332:	eb cf       	rjmp	.-42     	; 0x30a <__vector_4+0x7c>
	} else if(LED_Warning) {
 334:	80 91 74 00 	lds	r24, 0x0074
 338:	88 23       	and	r24, r24
 33a:	99 f0       	breq	.+38     	; 0x362 <__vector_4+0xd4>
		LED_Warning_WorkLong = (LED_Warning & 0xF0) >> 4;
 33c:	80 91 74 00 	lds	r24, 0x0074
 340:	82 95       	swap	r24
 342:	8f 70       	andi	r24, 0x0F	; 15
 344:	80 93 65 00 	sts	0x0065, r24
		LED_Warning_WorkShort = LED_Warning & 0x0F;
 348:	80 91 74 00 	lds	r24, 0x0074
 34c:	8f 70       	andi	r24, 0x0F	; 15
 34e:	80 93 64 00 	sts	0x0064, r24
		if(LED_Warning_NoRepeat) {
 352:	80 91 63 00 	lds	r24, 0x0063
 356:	88 23       	and	r24, r24
 358:	21 f0       	breq	.+8      	; 0x362 <__vector_4+0xd4>
			LED_Warning_NoRepeat = 0;
 35a:	10 92 63 00 	sts	0x0063, r1
			LED_Warning = 0;
 35e:	10 92 74 00 	sts	0x0074, r1
		}
	}
}
 362:	9f 91       	pop	r25
 364:	8f 91       	pop	r24
 366:	0f 90       	pop	r0
 368:	0f be       	out	0x3f, r0	; 63
 36a:	0f 90       	pop	r0
 36c:	1f 90       	pop	r1
 36e:	18 95       	reti

00000370 <__vector_13>:

ISR(ADC_vect) // Light sensor
{
 370:	1f 92       	push	r1
 372:	0f 92       	push	r0
 374:	0f b6       	in	r0, 0x3f	; 63
 376:	0f 92       	push	r0
 378:	11 24       	eor	r1, r1
 37a:	2f 93       	push	r18
 37c:	8f 93       	push	r24
 37e:	9f 93       	push	r25
	LowLight = ADCH >= LowLightThreshold;
 380:	25 b1       	in	r18, 0x05	; 5
 382:	81 e0       	ldi	r24, 0x01	; 1
 384:	90 91 75 00 	lds	r25, 0x0075
 388:	29 17       	cp	r18, r25
 38a:	08 f4       	brcc	.+2      	; 0x38e <__vector_13+0x1e>
 38c:	80 e0       	ldi	r24, 0x00	; 0
 38e:	80 93 73 00 	sts	0x0073, r24
}
 392:	9f 91       	pop	r25
 394:	8f 91       	pop	r24
 396:	2f 91       	pop	r18
 398:	0f 90       	pop	r0
 39a:	0f be       	out	0x3f, r0	; 63
 39c:	0f 90       	pop	r0
 39e:	1f 90       	pop	r1
 3a0:	18 95       	reti

000003a2 <__vector_2>:

ISR(PCINT0_vect) // Sensor
{
 3a2:	1f 92       	push	r1
 3a4:	0f 92       	push	r0
 3a6:	0f b6       	in	r0, 0x3f	; 63
 3a8:	0f 92       	push	r0
 3aa:	11 24       	eor	r1, r1
 3ac:	2f 93       	push	r18
 3ae:	3f 93       	push	r19
 3b0:	8f 93       	push	r24
 3b2:	9f 93       	push	r25
	if(CO2SensorState)
 3b4:	c8 9b       	sbis	0x19, 0	; 25
 3b6:	03 c0       	rjmp	.+6      	; 0x3be <__vector_2+0x1c>
	{ // Hi state
		TCNT1 = 0;
 3b8:	1d bc       	out	0x2d, r1	; 45
 3ba:	1c bc       	out	0x2c, r1	; 44
 3bc:	13 c0       	rjmp	.+38     	; 0x3e4 <__vector_2+0x42>
	} else {
		CO2Level = (CO2Level + (TCNT1 / 4 - 4)) / 2; // tick = 0.125 ms, 350 ppm = 177ms, 2000 ppm = 1002ms
 3be:	2c b5       	in	r18, 0x2c	; 44
 3c0:	3d b5       	in	r19, 0x2d	; 45
 3c2:	80 91 71 00 	lds	r24, 0x0071
 3c6:	90 91 72 00 	lds	r25, 0x0072
 3ca:	04 97       	sbiw	r24, 0x04	; 4
 3cc:	36 95       	lsr	r19
 3ce:	27 95       	ror	r18
 3d0:	36 95       	lsr	r19
 3d2:	27 95       	ror	r18
 3d4:	82 0f       	add	r24, r18
 3d6:	93 1f       	adc	r25, r19
 3d8:	96 95       	lsr	r25
 3da:	87 95       	ror	r24
 3dc:	90 93 72 00 	sts	0x0072, r25
 3e0:	80 93 71 00 	sts	0x0071, r24
	}
}
 3e4:	9f 91       	pop	r25
 3e6:	8f 91       	pop	r24
 3e8:	3f 91       	pop	r19
 3ea:	2f 91       	pop	r18
 3ec:	0f 90       	pop	r0
 3ee:	0f be       	out	0x3f, r0	; 63
 3f0:	0f 90       	pop	r0
 3f2:	1f 90       	pop	r1
 3f4:	18 95       	reti

000003f6 <__vector_8>:

ISR(TIM1_OVF_vect) // Sensor error show
{
 3f6:	1f 92       	push	r1
 3f8:	0f 92       	push	r0
 3fa:	0f b6       	in	r0, 0x3f	; 63
 3fc:	0f 92       	push	r0
 3fe:	11 24       	eor	r1, r1
 400:	8f 93       	push	r24
	if(LED_Warning == 0 && Setup == 0) {
 402:	80 91 74 00 	lds	r24, 0x0074
 406:	81 11       	cpse	r24, r1
 408:	0a c0       	rjmp	.+20     	; 0x41e <__vector_8+0x28>
 40a:	80 91 6a 00 	lds	r24, 0x006A
 40e:	81 11       	cpse	r24, r1
 410:	06 c0       	rjmp	.+12     	; 0x41e <__vector_8+0x28>
		LED_Warning = ERR_CO2Sensor;
 412:	80 e4       	ldi	r24, 0x40	; 64
 414:	80 93 74 00 	sts	0x0074, r24
		LED_Warning_NoRepeat = 1;
 418:	81 e0       	ldi	r24, 0x01	; 1
 41a:	80 93 63 00 	sts	0x0063, r24
	}
}
 41e:	8f 91       	pop	r24
 420:	0f 90       	pop	r0
 422:	0f be       	out	0x3f, r0	; 63
 424:	0f 90       	pop	r0
 426:	1f 90       	pop	r1
 428:	18 95       	reti

0000042a <__vector_11>:

#define HASH_UPDATE IRHash = (IRHash << 4) + IRHash + IRReadedByte // hash=hash*17+b (better: hash=hash*33+b)
//#define HASH_UPDATE IRHash = _crc_ccitt_update(IRHash, IRReadedByte)
ISR(TIM0_OVF_vect) // IR
{
 42a:	1f 92       	push	r1
 42c:	0f 92       	push	r0
 42e:	0f b6       	in	r0, 0x3f	; 63
 430:	0f 92       	push	r0
 432:	11 24       	eor	r1, r1
 434:	2f 93       	push	r18
 436:	3f 93       	push	r19
 438:	4f 93       	push	r20
 43a:	5f 93       	push	r21
 43c:	8f 93       	push	r24
 43e:	9f 93       	push	r25
	if(++IRSignalTimer == 0) { // overflow - command end
 440:	80 91 6e 00 	lds	r24, 0x006E
 444:	8f 5f       	subi	r24, 0xFF	; 255
 446:	80 93 6e 00 	sts	0x006E, r24
 44a:	81 11       	cpse	r24, r1
 44c:	34 c0       	rjmp	.+104    	; 0x4b6 <__vector_11+0x8c>
		if(IRReceived != IRIsCommandReceived) {
 44e:	80 91 6d 00 	lds	r24, 0x006D
 452:	83 30       	cpi	r24, 0x03	; 3
 454:	81 f1       	breq	.+96     	; 0x4b6 <__vector_11+0x8c>
 456:	40 91 6c 00 	lds	r20, 0x006C
			if(KEY1_PRESSING) { // key pressed
 45a:	b2 99       	sbic	0x16, 2	; 22
 45c:	08 c0       	rjmp	.+16     	; 0x46e <__vector_11+0x44>
				if(Key1Pressed != 255) Key1Pressed++;
 45e:	4f 3f       	cpi	r20, 0xFF	; 255
 460:	19 f0       	breq	.+6      	; 0x468 <__vector_11+0x3e>
 462:	4f 5f       	subi	r20, 0xFF	; 255
 464:	40 93 6c 00 	sts	0x006C, r20
				IRReceived = 0;
 468:	10 92 6d 00 	sts	0x006D, r1
 46c:	24 c0       	rjmp	.+72     	; 0x4b6 <__vector_11+0x8c>
			} else {
				if(IRReceived == 2 && IRHead) {
 46e:	82 30       	cpi	r24, 0x02	; 2
 470:	e1 f4       	brne	.+56     	; 0x4aa <__vector_11+0x80>
 472:	80 91 76 00 	lds	r24, 0x0076
 476:	88 23       	and	r24, r24
 478:	c1 f0       	breq	.+48     	; 0x4aa <__vector_11+0x80>
					IRReceived = IRIsCommandReceived; 
 47a:	83 e0       	ldi	r24, 0x03	; 3
 47c:	80 93 6d 00 	sts	0x006D, r24
					HASH_UPDATE;
 480:	20 91 78 00 	lds	r18, 0x0078
 484:	30 91 79 00 	lds	r19, 0x0079
 488:	c9 01       	movw	r24, r18
 48a:	54 e0       	ldi	r21, 0x04	; 4
 48c:	88 0f       	add	r24, r24
 48e:	99 1f       	adc	r25, r25
 490:	5a 95       	dec	r21
 492:	e1 f7       	brne	.-8      	; 0x48c <__vector_11+0x62>
 494:	50 91 85 00 	lds	r21, 0x0085
 498:	85 0f       	add	r24, r21
 49a:	91 1d       	adc	r25, r1
 49c:	82 0f       	add	r24, r18
 49e:	93 1f       	adc	r25, r19
 4a0:	90 93 79 00 	sts	0x0079, r25
 4a4:	80 93 78 00 	sts	0x0078, r24
 4a8:	02 c0       	rjmp	.+4      	; 0x4ae <__vector_11+0x84>
				} else IRReceived = 0;
 4aa:	10 92 6d 00 	sts	0x006D, r1
				if(Key1Pressed < KEY1_PressingTimeMin) Key1Pressed = 0;
 4ae:	4a 30       	cpi	r20, 0x0A	; 10
 4b0:	10 f4       	brcc	.+4      	; 0x4b6 <__vector_11+0x8c>
 4b2:	10 92 6c 00 	sts	0x006C, r1
			}
		}
	}
}
 4b6:	9f 91       	pop	r25
 4b8:	8f 91       	pop	r24
 4ba:	5f 91       	pop	r21
 4bc:	4f 91       	pop	r20
 4be:	3f 91       	pop	r19
 4c0:	2f 91       	pop	r18
 4c2:	0f 90       	pop	r0
 4c4:	0f be       	out	0x3f, r0	; 63
 4c6:	0f 90       	pop	r0
 4c8:	1f 90       	pop	r1
 4ca:	18 95       	reti

000004cc <__vector_3>:

ISR(PCINT1_vect) // IR
{
 4cc:	1f 92       	push	r1
 4ce:	0f 92       	push	r0
 4d0:	0f b6       	in	r0, 0x3f	; 63
 4d2:	0f 92       	push	r0
 4d4:	11 24       	eor	r1, r1
 4d6:	2f 93       	push	r18
 4d8:	3f 93       	push	r19
 4da:	4f 93       	push	r20
 4dc:	5f 93       	push	r21
 4de:	8f 93       	push	r24
 4e0:	9f 93       	push	r25
	uint8_t bit;
	if(IRReceived == 0) {
 4e2:	80 91 6d 00 	lds	r24, 0x006D
 4e6:	81 11       	cpse	r24, r1
 4e8:	10 c0       	rjmp	.+32     	; 0x50a <__vector_3+0x3e>
		IRReceived = 1; // Start
 4ea:	81 e0       	ldi	r24, 0x01	; 1
 4ec:	80 93 6d 00 	sts	0x006D, r24
		IRSignalTimerLast = 0;
 4f0:	10 92 8c 00 	sts	0x008C, r1
		IRArrayBit = 0;
 4f4:	10 92 77 00 	sts	0x0077, r1
		IRReadedByte = 0;
 4f8:	10 92 85 00 	sts	0x0085, r1
		IRHash = 5381; // hash init
 4fc:	85 e0       	ldi	r24, 0x05	; 5
 4fe:	95 e1       	ldi	r25, 0x15	; 21
 500:	90 93 79 00 	sts	0x0079, r25
 504:	80 93 78 00 	sts	0x0078, r24
		//IRHash = 0xFFFF; // crc init
		goto xEnd;
 508:	54 c0       	rjmp	.+168    	; 0x5b2 <__vector_3+0xe6>
	} else if(IRReceived < IRIsCommandReceived) {
 50a:	83 30       	cpi	r24, 0x03	; 3
 50c:	08 f0       	brcs	.+2      	; 0x510 <__vector_3+0x44>
 50e:	53 c0       	rjmp	.+166    	; 0x5b6 <__vector_3+0xea>
 510:	40 91 6e 00 	lds	r20, 0x006E
		if(IRReceived == 1) { // Check first pulse width 
 514:	81 30       	cpi	r24, 0x01	; 1
 516:	a1 f4       	brne	.+40     	; 0x540 <__vector_3+0x74>
			uint8_t head = IRSignalTimer / 8;
 518:	84 2f       	mov	r24, r20
 51a:	86 95       	lsr	r24
 51c:	86 95       	lsr	r24
 51e:	86 95       	lsr	r24
			if(head == IRHead) {
 520:	90 91 76 00 	lds	r25, 0x0076
 524:	89 17       	cp	r24, r25
 526:	31 f0       	breq	.+12     	; 0x534 <__vector_3+0x68>
				IRReceived = 2;
			} else if(SetupIR) {
 528:	90 91 6b 00 	lds	r25, 0x006B
 52c:	99 23       	and	r25, r25
 52e:	31 f0       	breq	.+12     	; 0x53c <__vector_3+0x70>
				IRHead = head;
 530:	80 93 76 00 	sts	0x0076, r24
				IRReceived = 2;
 534:	82 e0       	ldi	r24, 0x02	; 2
 536:	80 93 6d 00 	sts	0x006D, r24
 53a:	02 c0       	rjmp	.+4      	; 0x540 <__vector_3+0x74>
			} else {
				IRReceived = 0;
 53c:	10 92 6d 00 	sts	0x006D, r1
			}
		}
		if(IRSignalTimer > IRSignalTimerLast) // bit = a / b > 1.5
 540:	80 91 8c 00 	lds	r24, 0x008C
 544:	84 17       	cp	r24, r20
 546:	30 f4       	brcc	.+12     	; 0x554 <__vector_3+0x88>
			bit = (uint8_t)(IRSignalTimer - IRSignalTimerLast) > IRSignalTimerLast / 2;
 548:	24 2f       	mov	r18, r20
 54a:	28 1b       	sub	r18, r24
 54c:	98 2f       	mov	r25, r24
 54e:	96 95       	lsr	r25
 550:	81 e0       	ldi	r24, 0x01	; 1
 552:	05 c0       	rjmp	.+10     	; 0x55e <__vector_3+0x92>
		else
			bit = (uint8_t)(IRSignalTimerLast - IRSignalTimer) > IRSignalTimer / 2;
 554:	28 2f       	mov	r18, r24
 556:	24 1b       	sub	r18, r20
 558:	81 e0       	ldi	r24, 0x01	; 1
 55a:	94 2f       	mov	r25, r20
 55c:	96 95       	lsr	r25
 55e:	92 17       	cp	r25, r18
 560:	08 f0       	brcs	.+2      	; 0x564 <__vector_3+0x98>
 562:	80 e0       	ldi	r24, 0x00	; 0
		IRReadedByte = (IRReadedByte << 1) | bit;
 564:	50 91 85 00 	lds	r21, 0x0085
 568:	55 0f       	add	r21, r21
 56a:	58 2b       	or	r21, r24
 56c:	50 93 85 00 	sts	0x0085, r21
		if(++IRArrayBit > 7) {
 570:	80 91 77 00 	lds	r24, 0x0077
 574:	8f 5f       	subi	r24, 0xFF	; 255
 576:	88 30       	cpi	r24, 0x08	; 8
 578:	18 f4       	brcc	.+6      	; 0x580 <__vector_3+0xb4>
 57a:	80 93 77 00 	sts	0x0077, r24
 57e:	17 c0       	rjmp	.+46     	; 0x5ae <__vector_3+0xe2>
			IRArrayBit = 0;
 580:	10 92 77 00 	sts	0x0077, r1
			HASH_UPDATE;
 584:	20 91 78 00 	lds	r18, 0x0078
 588:	30 91 79 00 	lds	r19, 0x0079
 58c:	c9 01       	movw	r24, r18
 58e:	82 95       	swap	r24
 590:	92 95       	swap	r25
 592:	90 7f       	andi	r25, 0xF0	; 240
 594:	98 27       	eor	r25, r24
 596:	80 7f       	andi	r24, 0xF0	; 240
 598:	98 27       	eor	r25, r24
 59a:	82 0f       	add	r24, r18
 59c:	93 1f       	adc	r25, r19
 59e:	85 0f       	add	r24, r21
 5a0:	91 1d       	adc	r25, r1
 5a2:	90 93 79 00 	sts	0x0079, r25
 5a6:	80 93 78 00 	sts	0x0078, r24
			IRReadedByte = 0;
 5aa:	10 92 85 00 	sts	0x0085, r1
		}
	IRSignalTimerLast = IRSignalTimer;
 5ae:	40 93 8c 00 	sts	0x008C, r20
xEnd:	IRSignalTimer = 0;
 5b2:	10 92 6e 00 	sts	0x006E, r1
	}
}
 5b6:	9f 91       	pop	r25
 5b8:	8f 91       	pop	r24
 5ba:	5f 91       	pop	r21
 5bc:	4f 91       	pop	r20
 5be:	3f 91       	pop	r19
 5c0:	2f 91       	pop	r18
 5c2:	0f 90       	pop	r0
 5c4:	0f be       	out	0x3f, r0	; 63
 5c6:	0f 90       	pop	r0
 5c8:	1f 90       	pop	r1
 5ca:	18 95       	reti

000005cc <Set_LED_Warning>:

void Set_LED_Warning(uint8_t d)
{
	if(LED_Warning == 0 && Setup == 0) {
 5cc:	90 91 74 00 	lds	r25, 0x0074
 5d0:	91 11       	cpse	r25, r1
 5d2:	09 c0       	rjmp	.+18     	; 0x5e6 <Set_LED_Warning+0x1a>
 5d4:	90 91 6a 00 	lds	r25, 0x006A
 5d8:	91 11       	cpse	r25, r1
 5da:	05 c0       	rjmp	.+10     	; 0x5e6 <Set_LED_Warning+0x1a>
		LED_Warning_NoRepeat = 1;
 5dc:	91 e0       	ldi	r25, 0x01	; 1
 5de:	90 93 63 00 	sts	0x0063, r25
		LED_Warning = d;
 5e2:	80 93 74 00 	sts	0x0074, r24
 5e6:	08 95       	ret

000005e8 <ShowFanSpeedOverride>:
	}
}

void ShowFanSpeedOverride(int8_t speed)
{
	LED_WarningOnCnt = 0;
 5e8:	10 92 67 00 	sts	0x0067, r1
	LED_WarningOffCnt = 4;  // 0.5sec
 5ec:	94 e0       	ldi	r25, 0x04	; 4
 5ee:	90 93 66 00 	sts	0x0066, r25
	LED_Warning_NoRepeat = 1;
 5f2:	91 e0       	ldi	r25, 0x01	; 1
 5f4:	90 93 63 00 	sts	0x0063, r25
	if(speed >= 0)
 5f8:	87 fd       	sbrc	r24, 7
 5fa:	03 c0       	rjmp	.+6      	; 0x602 <ShowFanSpeedOverride+0x1a>
		LED_Warning = speed;
 5fc:	80 93 74 00 	sts	0x0074, r24
 600:	08 95       	ret
	else {
		LED_Warning = -speed + 0x10;
 602:	90 e1       	ldi	r25, 0x10	; 16
 604:	98 1b       	sub	r25, r24
 606:	90 93 74 00 	sts	0x0074, r25
 60a:	08 95       	ret

0000060c <main>:
	}
}

int main(void)
{
	CLKPR = (1<<CLKPCE); CLKPR = (0<<CLKPS3) | (0<<CLKPS2) | (0<<CLKPS1) | (0<<CLKPS0); // Clock prescaler division factor: 1
 60c:	20 e8       	ldi	r18, 0x80	; 128
 60e:	26 bd       	out	0x26, r18	; 38
 610:	16 bc       	out	0x26, r1	; 38
	MCUCR = (1<<SE) | (0<<SM1) | (0<<SM0); // Idle sleep enable
 612:	80 e2       	ldi	r24, 0x20	; 32
 614:	85 bf       	out	0x35, r24	; 53
	DDRA = LED1; // Out
 616:	92 e0       	ldi	r25, 0x02	; 2
 618:	9a bb       	out	0x1a, r25	; 26
	NRF24_DDR |= NRF24_CE | NRF24_CSN | NRF24_SCK | NRF24_MOSI; // Out
 61a:	8a b3       	in	r24, 0x1a	; 26
 61c:	8c 63       	ori	r24, 0x3C	; 60
 61e:	8a bb       	out	0x1a, r24	; 26
	PORTA = (1<<PORTA7); // pull up: Photo resistor LDR1
 620:	2b bb       	out	0x1b, r18	; 27
	PORTB = (1<<PORTB0) | (1<<PORTB1); // Pullup not used
 622:	83 e0       	ldi	r24, 0x03	; 3
 624:	88 bb       	out	0x18, r24	; 24
	// Timer 8 bit		NRF24L01_Buffer	Unknown identifier	Error
	TCCR0A = (1<<WGM01) | (1<<WGM00);  // Timer0: Fast PWM OCRA
 626:	80 bf       	out	0x30, r24	; 48
	TCCR0B = (1<<WGM02) | (0 << CS02) | (1 << CS01) | (0 << CS00); // Timer0 prescaller: 8
 628:	8a e0       	ldi	r24, 0x0A	; 10
 62a:	83 bf       	out	0x33, r24	; 51
	OCR0A = 49; // OC0A - Fclk/(prescaller*(1+TOP)) = 20480hz
 62c:	81 e3       	ldi	r24, 0x31	; 49
 62e:	86 bf       	out	0x36, r24	; 54
	OCR0B = 0; // Half Duty cycle ((TOP+1)/2-1)
 630:	1c be       	out	0x3c, r1	; 60
	// Timer 16 bit
	TCCR1A = (1<<WGM11) | (0<<WGM10);  // Timer1: Fast PWM Top ICR1 (14)
 632:	9f bd       	out	0x2f, r25	; 47
	TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS12) | (0<<CS11) | (1<<CS10); // Timer1: /1024
 634:	8d e1       	ldi	r24, 0x1D	; 29
 636:	8e bd       	out	0x2e, r24	; 46
	ICR1 = 16000; // Max sensor value * 4. Sensor value must be less than 255 * 16 = 4080
 638:	80 e8       	ldi	r24, 0x80	; 128
 63a:	9e e3       	ldi	r25, 0x3E	; 62
 63c:	95 bd       	out	0x25, r25	; 37
 63e:	84 bd       	out	0x24, r24	; 36
	if(EEPROM_read(EPROM_ShowCO2SensorError)) {
 640:	85 e0       	ldi	r24, 0x05	; 5
 642:	43 dd       	rcall	.-1402   	; 0xca <EEPROM_read>
 644:	88 23       	and	r24, r24
 646:	11 f0       	breq	.+4      	; 0x64c <main+0x40>
		TIMSK1 = (1<<TOIE1); // Timer/Counter1, Overflow Interrupt Enable
 648:	81 e0       	ldi	r24, 0x01	; 1
 64a:	8c b9       	out	0x0c, r24	; 12
	}
	// ADC
 	ADMUX = (0<<REFS1) | (1<<MUX2)|(1<<MUX1)|(1<<MUX0); // ADC7 (PA7)
 64c:	87 e0       	ldi	r24, 0x07	; 7
 64e:	87 b9       	out	0x07, r24	; 7
 	ADCSRA = (1<<ADEN) | (0<<ADATE) | (1<<ADIE) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); // ADC enable, Free Running mode, Interrupt, ADC 128 divider
 650:	9f e8       	ldi	r25, 0x8F	; 143
 652:	96 b9       	out	0x06, r25	; 6
 	ADCSRB = (1<<ADLAR) | (0<<ADTS2) | (0<<ADTS1) | (0<<ADTS0); // ADC Left Adjust Result
 654:	90 e1       	ldi	r25, 0x10	; 16
 656:	93 b9       	out	0x03, r25	; 3
	// Pin change
 	GIMSK = (1<<PCIE0) | (1<<PCIE1); // Pin Change Interrupt Enable 0, 1
 658:	90 e3       	ldi	r25, 0x30	; 48
 65a:	9b bf       	out	0x3b, r25	; 59
 	PCMSK0 = (1<<PCINT0); // Pin Change Mask Register 0 - Sensor
 65c:	91 e0       	ldi	r25, 0x01	; 1
 65e:	92 bb       	out	0x12, r25	; 18
 	PCMSK1 = (1<<PCINT8) | (1<<PCINT9) | (1<<PCINT10); // Pin Change Mask Register 0 - Keys
 660:	80 bd       	out	0x20, r24	; 32
	LowLightThreshold = EEPROM_read(EPROM_LowLightThreshold);
 662:	81 e0       	ldi	r24, 0x01	; 1
 664:	32 dd       	rcall	.-1436   	; 0xca <EEPROM_read>
 666:	80 93 75 00 	sts	0x0075, r24
	if(LowLightThreshold == 0xFF) {
 66a:	8f 3f       	cpi	r24, 0xFF	; 255
 66c:	49 f4       	brne	.+18     	; 0x680 <main+0x74>
		EEPROM_write(EPROM_OSCCAL, OSCCAL);
 66e:	61 b7       	in	r22, 0x31	; 49
 670:	80 e0       	ldi	r24, 0x00	; 0
 672:	33 dd       	rcall	.-1434   	; 0xda <EEPROM_write>
		EEPROM_write(EPROM_NumberFans, 1);
 674:	61 e0       	ldi	r22, 0x01	; 1
 676:	82 e0       	ldi	r24, 0x02	; 2
 678:	30 dd       	rcall	.-1440   	; 0xda <EEPROM_write>
		EEPROM_write(EPROM_LowLightThreshold, 0x90);
 67a:	60 e9       	ldi	r22, 0x90	; 144
 67c:	81 e0       	ldi	r24, 0x01	; 1
 67e:	2d dd       	rcall	.-1446   	; 0xda <EEPROM_write>
	}
 	OSCCAL = EEPROM_read(EPROM_OSCCAL);
 680:	80 e0       	ldi	r24, 0x00	; 0
 682:	23 dd       	rcall	.-1466   	; 0xca <EEPROM_read>
 684:	81 bf       	out	0x31, r24	; 49
	// Prepare for IR receiving
	GIMSK |= (1<<PCIE1); // Pin Change Interrupt Enable 1
 686:	8b b7       	in	r24, 0x3b	; 59
 688:	80 62       	ori	r24, 0x20	; 32
 68a:	8b bf       	out	0x3b, r24	; 59
	PCMSK1 |= (1<<PCINT10); // Pin Change Mask Register 0 - Keys
 68c:	80 b5       	in	r24, 0x20	; 32
 68e:	84 60       	ori	r24, 0x04	; 4
 690:	80 bd       	out	0x20, r24	; 32
	TIMSK0 |= (1<<TOIE0); // Timer/Counter0 Overflow Interrupt Enable
 692:	89 b7       	in	r24, 0x39	; 57
 694:	81 60       	ori	r24, 0x01	; 1
 696:	89 bf       	out	0x39, r24	; 57
	IRHead = EEPROM_read(EPROM_IRCommandHead);
 698:	80 e3       	ldi	r24, 0x30	; 48
 69a:	17 dd       	rcall	.-1490   	; 0xca <EEPROM_read>
 69c:	80 93 76 00 	sts	0x0076, r24
	NRF24_init(EEPROM_read(EPROM_RF_Channel)); // After init transmit must be delayed
 6a0:	87 e0       	ldi	r24, 0x07	; 7
 6a2:	13 dd       	rcall	.-1498   	; 0xca <EEPROM_read>
 6a4:	dd dd       	rcall	.-1094   	; 0x260 <NRF24_init>
	FlashLED(3,3,3);
 6a6:	43 e0       	ldi	r20, 0x03	; 3
 6a8:	63 e0       	ldi	r22, 0x03	; 3
 6aa:	83 e0       	ldi	r24, 0x03	; 3
 6ac:	f4 dc       	rcall	.-1560   	; 0x96 <FlashLED>
	SETUP_WATCHDOG;
 6ae:	88 e1       	ldi	r24, 0x18	; 24
 6b0:	81 bd       	out	0x21, r24	; 33
 6b2:	8b e4       	ldi	r24, 0x4B	; 75
 6b4:	81 bd       	out	0x21, r24	; 33
	sei();
 6b6:	78 94       	sei
 6b8:	ed e8       	ldi	r30, 0x8D	; 141
 6ba:	f0 e0       	ldi	r31, 0x00	; 0
	for(uint8_t i = 0; i < MAX_FANS; i++) FanSpeedForce[i] = -1; // set auto
 6bc:	8f ef       	ldi	r24, 0xFF	; 255
 6be:	81 93       	st	Z+, r24
 6c0:	90 e0       	ldi	r25, 0x00	; 0
 6c2:	e7 39       	cpi	r30, 0x97	; 151
 6c4:	f9 07       	cpc	r31, r25
 6c6:	d9 f7       	brne	.-10     	; 0x6be <main+0xb2>
	NRF24_SetMode(NRF24_TransmitMode);
 6c8:	80 e0       	ldi	r24, 0x00	; 0
 6ca:	75 dd       	rcall	.-1302   	; 0x1b6 <NRF24_SetMode>
	if(EEPROM_read(EPROM_NumberFans) == 1) {
 6cc:	82 e0       	ldi	r24, 0x02	; 2
 6ce:	fd dc       	rcall	.-1542   	; 0xca <EEPROM_read>
 6d0:	81 30       	cpi	r24, 0x01	; 1
 6d2:	39 f0       	breq	.+14     	; 0x6e2 <main+0xd6>
	{
		__asm__ volatile ("" ::: "memory"); // Need memory barrier
		uint8_t i;
		sleep_cpu();
		IRKey = 0;
		if(IRReceived == IRIsCommandReceived) {
 6d4:	ee 24       	eor	r14, r14
 6d6:	e3 94       	inc	r14
				do {
					uint8_t j = EEPROM_read(i++);
					if(j == fan) {
						if((j = EEPROM_read(i++)) != 0xFF) { // Set RF channel
							NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH,	j);
							RF_Changed = 1;
 6d8:	01 e0       	ldi	r16, 0x01	; 1
xSetupIR:				SetupIR++;
						FlashLED(3, 1, 1);
						LED_Warning = SetupIR;
						Delay100ms(15);
						IRReceived = 0;
						Timer = 255;
 6da:	1f ef       	ldi	r17, 0xFF	; 255
						Setup--;
						FlashLED(5, 1, 1);
					}
				} else {
					if(KeyOkTimeout == 0)
						KeyOkTimeout = 5; // 0.6 sec wait for the next Ok pressing
 6dc:	f5 e0       	ldi	r31, 0x05	; 5
 6de:	ff 2e       	mov	r15, r31
 6e0:	1e c0       	rjmp	.+60     	; 0x71e <main+0x112>
	SETUP_WATCHDOG;
	sei();
	for(uint8_t i = 0; i < MAX_FANS; i++) FanSpeedForce[i] = -1; // set auto
	NRF24_SetMode(NRF24_TransmitMode);
	if(EEPROM_read(EPROM_NumberFans) == 1) {
		if(!NRF24_SetAddresses(EEPROM_read(EPROM_RFAddresses + 0))) {
 6e2:	80 e2       	ldi	r24, 0x20	; 32
 6e4:	f2 dc       	rcall	.-1564   	; 0xca <EEPROM_read>
 6e6:	97 dd       	rcall	.-1234   	; 0x216 <NRF24_SetAddresses>
 6e8:	81 11       	cpse	r24, r1
 6ea:	f4 cf       	rjmp	.-24     	; 0x6d4 <main+0xc8>
			Delay100ms(10);
 6ec:	8a e0       	ldi	r24, 0x0A	; 10
 6ee:	90 e0       	ldi	r25, 0x00	; 0
 6f0:	c4 dc       	rcall	.-1656   	; 0x7a <Delay100ms>
			Set_LED_Warning(ERR_RF_SetAddr);
 6f2:	80 e2       	ldi	r24, 0x20	; 32
 6f4:	6b df       	rcall	.-298    	; 0x5cc <Set_LED_Warning>
 6f6:	ee cf       	rjmp	.-36     	; 0x6d4 <main+0xc8>
				TCCR0A |= (1<<COM0B1);  // Freq out: pin OC0B
				DDRA |= (1<<PORTA7); // out
				goto xSetupOSCCAL;
				do {
					__asm__ volatile ("" ::: "memory"); // Need memory barrier
					LED1_ON;
 6f8:	d9 9a       	sbi	0x1b, 1	; 27
					sleep_cpu();
 6fa:	88 95       	sleep
					if(!KEY1_PRESSING) {
 6fc:	b2 99       	sbic	0x16, 2	; 22
 6fe:	5b c2       	rjmp	.+1206   	; 0xbb6 <main+0x5aa>
							}
xSetupOSCCAL:				Key1Pressed = 0;
							Timer = 255;
						}
					}
				} while(Timer);
 700:	80 91 61 00 	lds	r24, 0x0061
 704:	81 11       	cpse	r24, r1
 706:	f8 cf       	rjmp	.-16     	; 0x6f8 <main+0xec>
				FlashLED(7, 1, 1);
 708:	41 e0       	ldi	r20, 0x01	; 1
 70a:	61 e0       	ldi	r22, 0x01	; 1
 70c:	87 e0       	ldi	r24, 0x07	; 7
 70e:	c3 dc       	rcall	.-1658   	; 0x96 <FlashLED>
				EEPROM_write(EPROM_OSCCAL, OSCCAL);
 710:	61 b7       	in	r22, 0x31	; 49
 712:	80 e0       	ldi	r24, 0x00	; 0
 714:	e2 dc       	rcall	.-1596   	; 0xda <EEPROM_write>
				TCCR0A &= ~(1<<COM0B1);
 716:	80 b7       	in	r24, 0x30	; 48
 718:	8f 7d       	andi	r24, 0xDF	; 223
 71a:	80 bf       	out	0x30, r24	; 48
				DDRA &= ~(1<<PORTA7); // in
 71c:	d7 98       	cbi	0x1a, 7	; 26
	}
	while(1)
	{
		__asm__ volatile ("" ::: "memory"); // Need memory barrier
		uint8_t i;
		sleep_cpu();
 71e:	88 95       	sleep
		IRKey = 0;
 720:	10 92 87 00 	sts	0x0087, r1
		if(IRReceived == IRIsCommandReceived) {
 724:	80 91 6d 00 	lds	r24, 0x006D
 728:	83 30       	cpi	r24, 0x03	; 3
 72a:	b9 f4       	brne	.+46     	; 0x75a <main+0x14e>
 72c:	d1 e3       	ldi	r29, 0x31	; 49
 72e:	c1 e0       	ldi	r28, 0x01	; 1
			for(i = 0; i < IRCommands; i++) {
				if(EEPROM_read(EPROM_IRCommandArray + i * sizeof(IRHash)) == (uint8_t) (IRHash % 256)
 730:	8d 2f       	mov	r24, r29
 732:	cb dc       	rcall	.-1642   	; 0xca <EEPROM_read>
 734:	90 91 78 00 	lds	r25, 0x0078
 738:	89 13       	cpse	r24, r25
 73a:	09 c0       	rjmp	.+18     	; 0x74e <main+0x142>
					&& EEPROM_read(EPROM_IRCommandArray + i * sizeof(IRHash) + 1) == (uint8_t) (IRHash / 256)) IRKey = i + 1;
 73c:	81 e0       	ldi	r24, 0x01	; 1
 73e:	8d 0f       	add	r24, r29
 740:	c4 dc       	rcall	.-1656   	; 0xca <EEPROM_read>
 742:	90 91 79 00 	lds	r25, 0x0079
 746:	89 13       	cpse	r24, r25
 748:	02 c0       	rjmp	.+4      	; 0x74e <main+0x142>
 74a:	c0 93 87 00 	sts	0x0087, r28
 74e:	cf 5f       	subi	r28, 0xFF	; 255
 750:	de 5f       	subi	r29, 0xFE	; 254
		__asm__ volatile ("" ::: "memory"); // Need memory barrier
		uint8_t i;
		sleep_cpu();
		IRKey = 0;
		if(IRReceived == IRIsCommandReceived) {
			for(i = 0; i < IRCommands; i++) {
 752:	c5 30       	cpi	r28, 0x05	; 5
 754:	69 f7       	brne	.-38     	; 0x730 <main+0x124>
				if(EEPROM_read(EPROM_IRCommandArray + i * sizeof(IRHash)) == (uint8_t) (IRHash % 256)
					&& EEPROM_read(EPROM_IRCommandArray + i * sizeof(IRHash) + 1) == (uint8_t) (IRHash / 256)) IRKey = i + 1;
			}
			IRReceived = 0;
 756:	10 92 6d 00 	sts	0x006D, r1
		}
		switch(IRKey) {
 75a:	c0 91 87 00 	lds	r28, 0x0087
 75e:	c2 30       	cpi	r28, 0x02	; 2
 760:	09 f4       	brne	.+2      	; 0x764 <main+0x158>
 762:	59 c0       	rjmp	.+178    	; 0x816 <main+0x20a>
 764:	18 f4       	brcc	.+6      	; 0x76c <main+0x160>
 766:	c1 30       	cpi	r28, 0x01	; 1
 768:	41 f0       	breq	.+16     	; 0x77a <main+0x16e>
 76a:	f7 c1       	rjmp	.+1006   	; 0xb5a <main+0x54e>
 76c:	c3 30       	cpi	r28, 0x03	; 3
 76e:	09 f4       	brne	.+2      	; 0x772 <main+0x166>
 770:	a6 c0       	rjmp	.+332    	; 0x8be <main+0x2b2>
 772:	c4 30       	cpi	r28, 0x04	; 4
 774:	09 f4       	brne	.+2      	; 0x778 <main+0x16c>
 776:	53 c1       	rjmp	.+678    	; 0xa1e <main+0x412>
 778:	f0 c1       	rjmp	.+992    	; 0xb5a <main+0x54e>
			case IRKey_Up: {
				LED_Warning_WorkLong = 0;
 77a:	10 92 65 00 	sts	0x0065, r1
				LED_Warning_WorkShort = 0;
 77e:	10 92 64 00 	sts	0x0064, r1
				if(Setup == 0) {
 782:	80 91 6a 00 	lds	r24, 0x006A
 786:	81 11       	cpse	r24, r1
 788:	07 c0       	rjmp	.+14     	; 0x798 <main+0x18c>
					if(FanSpeedOverride < FanSpeedMax) {
 78a:	80 91 70 00 	lds	r24, 0x0070
 78e:	86 30       	cpi	r24, 0x06	; 6
 790:	0c f0       	brlt	.+2      	; 0x794 <main+0x188>
 792:	e3 c1       	rjmp	.+966    	; 0xb5a <main+0x54e>
						FanSpeedOverride++;
 794:	8f 5f       	subi	r24, 0xFF	; 255
 796:	49 c0       	rjmp	.+146    	; 0x82a <main+0x21e>
						Timer = 0;
					}
				} else {
					LED_Warning_WorkLong = 0;
					LED_Warning_WorkShort = 0;
					Timer = 255;
 798:	10 93 61 00 	sts	0x0061, r17
 79c:	90 91 7a 00 	lds	r25, 0x007A
					if(Setup == 1) {
 7a0:	81 30       	cpi	r24, 0x01	; 1
 7a2:	39 f4       	brne	.+14     	; 0x7b2 <main+0x1a6>
						if(++SetupItem > 5) SetupItem = 5; // Max menu item reached
 7a4:	9f 5f       	subi	r25, 0xFF	; 255
 7a6:	96 30       	cpi	r25, 0x06	; 6
 7a8:	08 f4       	brcc	.+2      	; 0x7ac <main+0x1a0>
 7aa:	4f c0       	rjmp	.+158    	; 0x84a <main+0x23e>
 7ac:	f0 92 7a 00 	sts	0x007A, r15
 7b0:	51 c0       	rjmp	.+162    	; 0x854 <main+0x248>
						LED_Warning = SetupItem;
					} else {
						if(SetupItem == 3) { // Modify EEPROM
 7b2:	93 30       	cpi	r25, 0x03	; 3
 7b4:	71 f4       	brne	.+28     	; 0x7d2 <main+0x1c6>
							if(Setup == 2) LED_Warning = ++datapos; else LED_Warning = ++data;
 7b6:	82 30       	cpi	r24, 0x02	; 2
 7b8:	21 f4       	brne	.+8      	; 0x7c2 <main+0x1b6>
 7ba:	80 91 69 00 	lds	r24, 0x0069
 7be:	8f 5f       	subi	r24, 0xFF	; 255
 7c0:	53 c0       	rjmp	.+166    	; 0x868 <main+0x25c>
 7c2:	80 91 68 00 	lds	r24, 0x0068
 7c6:	8f 5f       	subi	r24, 0xFF	; 255
 7c8:	80 93 68 00 	sts	0x0068, r24
 7cc:	80 93 74 00 	sts	0x0074, r24
 7d0:	c4 c1       	rjmp	.+904    	; 0xb5a <main+0x54e>
						} else if(SetupItem == 4) { // fans override
 7d2:	94 30       	cpi	r25, 0x04	; 4
 7d4:	09 f0       	breq	.+2      	; 0x7d8 <main+0x1cc>
 7d6:	c1 c1       	rjmp	.+898    	; 0xb5a <main+0x54e>
 7d8:	c0 91 69 00 	lds	r28, 0x0069
							if(Setup == 2) { // select fan
 7dc:	82 30       	cpi	r24, 0x02	; 2
 7de:	51 f4       	brne	.+20     	; 0x7f4 <main+0x1e8>
								if(datapos <= EEPROM_read(EPROM_NumberFans)) datapos++;
 7e0:	74 dc       	rcall	.-1816   	; 0xca <EEPROM_read>
 7e2:	8c 17       	cp	r24, r28
 7e4:	08 f4       	brcc	.+2      	; 0x7e8 <main+0x1dc>
 7e6:	53 c0       	rjmp	.+166    	; 0x88e <main+0x282>
 7e8:	80 91 69 00 	lds	r24, 0x0069
 7ec:	8f 5f       	subi	r24, 0xFF	; 255
 7ee:	80 93 69 00 	sts	0x0069, r24
 7f2:	4d c0       	rjmp	.+154    	; 0x88e <main+0x282>
								LED_Warning = datapos;
							} else { // fan override
								if(SetupType) { // Forced speed
 7f4:	80 91 86 00 	lds	r24, 0x0086
									if(FanSpeedForce[datapos - 1] < FanSpeedMax) {
 7f8:	ec 2f       	mov	r30, r28
 7fa:	f0 e0       	ldi	r31, 0x00	; 0
						} else if(SetupItem == 4) { // fans override
							if(Setup == 2) { // select fan
								if(datapos <= EEPROM_read(EPROM_NumberFans)) datapos++;
								LED_Warning = datapos;
							} else { // fan override
								if(SetupType) { // Forced speed
 7fc:	88 23       	and	r24, r24
 7fe:	19 f0       	breq	.+6      	; 0x806 <main+0x1fa>
									if(FanSpeedForce[datapos - 1] < FanSpeedMax) {
 800:	e4 57       	subi	r30, 0x74	; 116
 802:	ff 4f       	sbci	r31, 0xFF	; 255
 804:	02 c0       	rjmp	.+4      	; 0x80a <main+0x1fe>
										ShowFanSpeedOverride(++FanSpeedForce[datapos - 1]);
									}
								} else if(FanSpeedOverrideArray[datapos - 1] < FanSpeedMax) { // set delta
 806:	e6 58       	subi	r30, 0x86	; 134
 808:	ff 4f       	sbci	r31, 0xFF	; 255
 80a:	80 81       	ld	r24, Z
 80c:	86 30       	cpi	r24, 0x06	; 6
 80e:	0c f0       	brlt	.+2      	; 0x812 <main+0x206>
 810:	e8 c1       	rjmp	.+976    	; 0xbe2 <main+0x5d6>
									ShowFanSpeedOverride(++FanSpeedOverrideArray[datapos - 1]);
 812:	8f 5f       	subi	r24, 0xFF	; 255
 814:	51 c0       	rjmp	.+162    	; 0x8b8 <main+0x2ac>
						}
					}
				}
				break;
			} case IRKey_Down: {
				if(Setup == 0) {
 816:	80 91 6a 00 	lds	r24, 0x006A
 81a:	81 11       	cpse	r24, r1
 81c:	0a c0       	rjmp	.+20     	; 0x832 <main+0x226>
					if(FanSpeedOverride > -FanSpeedMax) {
 81e:	80 91 70 00 	lds	r24, 0x0070
 822:	8b 3f       	cpi	r24, 0xFB	; 251
 824:	0c f4       	brge	.+2      	; 0x828 <main+0x21c>
 826:	99 c1       	rjmp	.+818    	; 0xb5a <main+0x54e>
						FanSpeedOverride--;
 828:	81 50       	subi	r24, 0x01	; 1
 82a:	80 93 70 00 	sts	0x0070, r24
						ShowFanSpeedOverride(FanSpeedOverride);
 82e:	dc de       	rcall	.-584    	; 0x5e8 <ShowFanSpeedOverride>
 830:	92 c1       	rjmp	.+804    	; 0xb56 <main+0x54a>
						Timer = 0;
					}
				} else {
					LED_Warning_WorkLong = 0;
 832:	10 92 65 00 	sts	0x0065, r1
					LED_Warning_WorkShort = 0;
 836:	10 92 64 00 	sts	0x0064, r1
					Timer = 255;
 83a:	10 93 61 00 	sts	0x0061, r17
 83e:	90 91 7a 00 	lds	r25, 0x007A
					if(Setup == 1) {
 842:	81 30       	cpi	r24, 0x01	; 1
 844:	51 f4       	brne	.+20     	; 0x85a <main+0x24e>
						if(--SetupItem == 0) SetupItem = 1; // Min menu item reached
 846:	91 50       	subi	r25, 0x01	; 1
 848:	19 f0       	breq	.+6      	; 0x850 <main+0x244>
 84a:	90 93 7a 00 	sts	0x007A, r25
 84e:	02 c0       	rjmp	.+4      	; 0x854 <main+0x248>
 850:	80 93 7a 00 	sts	0x007A, r24
						LED_Warning = SetupItem;
 854:	80 91 7a 00 	lds	r24, 0x007A
 858:	b9 cf       	rjmp	.-142    	; 0x7cc <main+0x1c0>
					} else {
						if(SetupItem == 3) { // Modify EEPROM
 85a:	93 30       	cpi	r25, 0x03	; 3
 85c:	61 f4       	brne	.+24     	; 0x876 <main+0x26a>
							if(Setup == 2) LED_Warning = --datapos; else LED_Warning = --data;
 85e:	82 30       	cpi	r24, 0x02	; 2
 860:	31 f4       	brne	.+12     	; 0x86e <main+0x262>
 862:	80 91 69 00 	lds	r24, 0x0069
 866:	81 50       	subi	r24, 0x01	; 1
 868:	80 93 69 00 	sts	0x0069, r24
 86c:	af cf       	rjmp	.-162    	; 0x7cc <main+0x1c0>
 86e:	80 91 68 00 	lds	r24, 0x0068
 872:	81 50       	subi	r24, 0x01	; 1
 874:	a9 cf       	rjmp	.-174    	; 0x7c8 <main+0x1bc>
						} else if(SetupItem == 4) { // fans override - select fan
 876:	94 30       	cpi	r25, 0x04	; 4
 878:	09 f0       	breq	.+2      	; 0x87c <main+0x270>
 87a:	6f c1       	rjmp	.+734    	; 0xb5a <main+0x54e>
 87c:	e0 91 69 00 	lds	r30, 0x0069
							if(Setup == 2) { // select fan
 880:	82 30       	cpi	r24, 0x02	; 2
 882:	41 f4       	brne	.+16     	; 0x894 <main+0x288>
								if(datapos > 1) datapos--;
 884:	e2 30       	cpi	r30, 0x02	; 2
 886:	18 f0       	brcs	.+6      	; 0x88e <main+0x282>
 888:	e1 50       	subi	r30, 0x01	; 1
 88a:	e0 93 69 00 	sts	0x0069, r30
								LED_Warning = datapos;
 88e:	80 91 69 00 	lds	r24, 0x0069
 892:	9c cf       	rjmp	.-200    	; 0x7cc <main+0x1c0>
							} else { // fan override
								if(SetupType) { // Forced speed
 894:	80 91 86 00 	lds	r24, 0x0086
									if(FanSpeedForce[datapos - 1] > -1) {
 898:	f0 e0       	ldi	r31, 0x00	; 0
						} else if(SetupItem == 4) { // fans override - select fan
							if(Setup == 2) { // select fan
								if(datapos > 1) datapos--;
								LED_Warning = datapos;
							} else { // fan override
								if(SetupType) { // Forced speed
 89a:	88 23       	and	r24, r24
 89c:	31 f0       	breq	.+12     	; 0x8aa <main+0x29e>
									if(FanSpeedForce[datapos - 1] > -1) {
 89e:	e4 57       	subi	r30, 0x74	; 116
 8a0:	ff 4f       	sbci	r31, 0xFF	; 255
 8a2:	80 81       	ld	r24, Z
 8a4:	87 fd       	sbrc	r24, 7
 8a6:	9d c1       	rjmp	.+826    	; 0xbe2 <main+0x5d6>
 8a8:	06 c0       	rjmp	.+12     	; 0x8b6 <main+0x2aa>
										ShowFanSpeedOverride(--FanSpeedForce[datapos - 1]);
									}
								} else if(FanSpeedOverrideArray[datapos - 1] > -FanSpeedMax) { // set delta
 8aa:	e6 58       	subi	r30, 0x86	; 134
 8ac:	ff 4f       	sbci	r31, 0xFF	; 255
 8ae:	80 81       	ld	r24, Z
 8b0:	8b 3f       	cpi	r24, 0xFB	; 251
 8b2:	0c f4       	brge	.+2      	; 0x8b6 <main+0x2aa>
 8b4:	96 c1       	rjmp	.+812    	; 0xbe2 <main+0x5d6>
									ShowFanSpeedOverride(--FanSpeedOverrideArray[datapos - 1]);
 8b6:	81 50       	subi	r24, 0x01	; 1
 8b8:	80 83       	st	Z, r24
 8ba:	96 de       	rcall	.-724    	; 0x5e8 <ShowFanSpeedOverride>
 8bc:	92 c1       	rjmp	.+804    	; 0xbe2 <main+0x5d6>
						}
					}
				}
				break;
			} case IRKey_Ok: {
				if(Setup) {
 8be:	80 91 6a 00 	lds	r24, 0x006A
 8c2:	88 23       	and	r24, r24
 8c4:	09 f4       	brne	.+2      	; 0x8c8 <main+0x2bc>
 8c6:	99 c0       	rjmp	.+306    	; 0x9fa <main+0x3ee>
					FlashLED(1,1,1);
 8c8:	41 e0       	ldi	r20, 0x01	; 1
 8ca:	61 e0       	ldi	r22, 0x01	; 1
 8cc:	81 e0       	ldi	r24, 0x01	; 1
 8ce:	e3 db       	rcall	.-2106   	; 0x96 <FlashLED>
					Timer = 255;
 8d0:	10 93 61 00 	sts	0x0061, r17
					switch(SetupItem) {
 8d4:	80 91 7a 00 	lds	r24, 0x007A
 8d8:	83 30       	cpi	r24, 0x03	; 3
 8da:	51 f1       	breq	.+84     	; 0x930 <main+0x324>
 8dc:	30 f4       	brcc	.+12     	; 0x8ea <main+0x2de>
 8de:	81 30       	cpi	r24, 0x01	; 1
 8e0:	09 f4       	brne	.+2      	; 0x8e4 <main+0x2d8>
 8e2:	33 c1       	rjmp	.+614    	; 0xb4a <main+0x53e>
 8e4:	82 30       	cpi	r24, 0x02	; 2
 8e6:	99 f0       	breq	.+38     	; 0x90e <main+0x302>
 8e8:	78 c0       	rjmp	.+240    	; 0x9da <main+0x3ce>
 8ea:	84 30       	cpi	r24, 0x04	; 4
 8ec:	09 f4       	brne	.+2      	; 0x8f0 <main+0x2e4>
 8ee:	46 c0       	rjmp	.+140    	; 0x97c <main+0x370>
 8f0:	85 30       	cpi	r24, 0x05	; 5
 8f2:	09 f0       	breq	.+2      	; 0x8f6 <main+0x2ea>
 8f4:	72 c0       	rjmp	.+228    	; 0x9da <main+0x3ce>
						} else { // delta entered
							LED_Warning = datapos;
						}
						break;
					case 5: // Show CO2 Level
						LED_Warning_WorkLong = 0;
 8f6:	10 92 65 00 	sts	0x0065, r1
						LED_Warning_WorkShort = 8;
 8fa:	88 e0       	ldi	r24, 0x08	; 8
 8fc:	80 93 64 00 	sts	0x0064, r24
						LED_Warning = CO2Level / 256;
 900:	80 91 72 00 	lds	r24, 0x0072
 904:	80 93 74 00 	sts	0x0074, r24
						LED_Warning_NoRepeat = 1;
 908:	00 93 63 00 	sts	0x0063, r16
 90c:	4c c0       	rjmp	.+152    	; 0x9a6 <main+0x39a>
					Timer = 255;
					switch(SetupItem) {
					case 1: // Exit setup
						goto xSetupExit;
					case 2: // Set Low light
						if(Setup == 1)
 90e:	80 91 6a 00 	lds	r24, 0x006A
 912:	81 30       	cpi	r24, 0x01	; 1
 914:	19 f4       	brne	.+6      	; 0x91c <main+0x310>
							LED_Warning = 0;
 916:	10 92 74 00 	sts	0x0074, r1
							Delay100ms(50);
							sleep_cpu();
							EEPROM_write(EPROM_LowLightThreshold, LowLightThreshold = ADCH);
							goto xSetupExit;
						}
						break;
 91a:	5f c0       	rjmp	.+190    	; 0x9da <main+0x3ce>
						goto xSetupExit;
					case 2: // Set Low light
						if(Setup == 1)
							LED_Warning = 0;
						else {
							Delay100ms(50);
 91c:	82 e3       	ldi	r24, 0x32	; 50
 91e:	90 e0       	ldi	r25, 0x00	; 0
 920:	ac db       	rcall	.-2216   	; 0x7a <Delay100ms>
							sleep_cpu();
 922:	88 95       	sleep
							EEPROM_write(EPROM_LowLightThreshold, LowLightThreshold = ADCH);
 924:	65 b1       	in	r22, 0x05	; 5
 926:	60 93 75 00 	sts	0x0075, r22
 92a:	81 e0       	ldi	r24, 0x01	; 1
 92c:	d6 db       	rcall	.-2132   	; 0xda <EEPROM_write>
							goto xSetupExit;
 92e:	0d c1       	rjmp	.+538    	; 0xb4a <main+0x53e>
						}
						break;
					case 3: // Edit EEPROM
						LED_Warning = 0; LED_Warning_WorkLong = 0; LED_Warning_WorkShort = 0;
 930:	10 92 74 00 	sts	0x0074, r1
 934:	10 92 65 00 	sts	0x0065, r1
 938:	10 92 64 00 	sts	0x0064, r1
						if(Setup == 1) {
 93c:	80 91 6a 00 	lds	r24, 0x006A
 940:	81 30       	cpi	r24, 0x01	; 1
 942:	c9 f0       	breq	.+50     	; 0x976 <main+0x36a>
							LED_Warning = datapos = 1;
						} else if(Setup == 2) {
 944:	82 30       	cpi	r24, 0x02	; 2
 946:	41 f4       	brne	.+16     	; 0x958 <main+0x34c>
							LED_Warning = data = EEPROM_read(datapos);
 948:	80 91 69 00 	lds	r24, 0x0069
 94c:	be db       	rcall	.-2180   	; 0xca <EEPROM_read>
 94e:	80 93 68 00 	sts	0x0068, r24
 952:	80 93 74 00 	sts	0x0074, r24
 956:	41 c0       	rjmp	.+130    	; 0x9da <main+0x3ce>
						} else if(data != EEPROM_read(datapos)) {
 958:	c0 91 68 00 	lds	r28, 0x0068
 95c:	80 91 69 00 	lds	r24, 0x0069
 960:	b4 db       	rcall	.-2200   	; 0xca <EEPROM_read>
 962:	c8 17       	cp	r28, r24
 964:	d1 f1       	breq	.+116    	; 0x9da <main+0x3ce>
							EEPROM_write(datapos, data);
 966:	60 91 68 00 	lds	r22, 0x0068
 96a:	80 91 69 00 	lds	r24, 0x0069
 96e:	b5 db       	rcall	.-2198   	; 0xda <EEPROM_write>
							LED_Warning = ++datapos;
 970:	80 91 69 00 	lds	r24, 0x0069
 974:	8f 5f       	subi	r24, 0xFF	; 255
 976:	80 93 69 00 	sts	0x0069, r24
 97a:	eb cf       	rjmp	.-42     	; 0x952 <main+0x346>
						}
						break;
					case 4: // Fans override: fan selected
						if(Setup == 2) { // fan selected
 97c:	80 91 6a 00 	lds	r24, 0x006A
 980:	e0 91 69 00 	lds	r30, 0x0069
 984:	82 30       	cpi	r24, 0x02	; 2
 986:	41 f4       	brne	.+16     	; 0x998 <main+0x38c>
							LED_Warning = 0;
 988:	10 92 74 00 	sts	0x0074, r1
							ShowFanSpeedOverride(FanSpeedOverrideArray[datapos - 1]);
 98c:	f0 e0       	ldi	r31, 0x00	; 0
 98e:	e6 58       	subi	r30, 0x86	; 134
 990:	ff 4f       	sbci	r31, 0xFF	; 255
 992:	80 81       	ld	r24, Z
 994:	29 de       	rcall	.-942    	; 0x5e8 <ShowFanSpeedOverride>
 996:	21 c0       	rjmp	.+66     	; 0x9da <main+0x3ce>
						} else { // delta entered
							LED_Warning = datapos;
 998:	e0 93 74 00 	sts	0x0074, r30
 99c:	1e c0       	rjmp	.+60     	; 0x9da <main+0x3ce>
						LED_Warning = CO2Level / 256;
						LED_Warning_NoRepeat = 1;
						do { 
							__asm__ volatile ("" ::: "memory"); // Need memory barrier
							sleep_cpu(); 
						} while(Timer && (LED_Warning || LED_WarningOffCnt || LED_Warning_WorkLong || LED_Warning_WorkShort));
 99e:	80 91 74 00 	lds	r24, 0x0074
 9a2:	88 23       	and	r24, r24
 9a4:	31 f0       	breq	.+12     	; 0x9b2 <main+0x3a6>
						LED_Warning_WorkShort = 8;
						LED_Warning = CO2Level / 256;
						LED_Warning_NoRepeat = 1;
						do { 
							__asm__ volatile ("" ::: "memory"); // Need memory barrier
							sleep_cpu(); 
 9a6:	88 95       	sleep
						} while(Timer && (LED_Warning || LED_WarningOffCnt || LED_Warning_WorkLong || LED_Warning_WorkShort));
 9a8:	80 91 61 00 	lds	r24, 0x0061
 9ac:	81 11       	cpse	r24, r1
 9ae:	f7 cf       	rjmp	.-18     	; 0x99e <main+0x392>
 9b0:	0c c0       	rjmp	.+24     	; 0x9ca <main+0x3be>
 9b2:	80 91 66 00 	lds	r24, 0x0066
 9b6:	81 11       	cpse	r24, r1
 9b8:	f6 cf       	rjmp	.-20     	; 0x9a6 <main+0x39a>
 9ba:	80 91 65 00 	lds	r24, 0x0065
 9be:	81 11       	cpse	r24, r1
 9c0:	f2 cf       	rjmp	.-28     	; 0x9a6 <main+0x39a>
 9c2:	80 91 64 00 	lds	r24, 0x0064
 9c6:	81 11       	cpse	r24, r1
 9c8:	ee cf       	rjmp	.-36     	; 0x9a6 <main+0x39a>
						LED_Warning = CO2Level % 256;
 9ca:	80 91 71 00 	lds	r24, 0x0071
 9ce:	80 93 74 00 	sts	0x0074, r24
						LED_Warning_NoRepeat = 1;
 9d2:	00 93 63 00 	sts	0x0063, r16
						Setup = 0;
 9d6:	10 92 6a 00 	sts	0x006A, r1
						break;
					}
					if(Setup < 3)
 9da:	80 91 6a 00 	lds	r24, 0x006A
 9de:	83 30       	cpi	r24, 0x03	; 3
 9e0:	20 f4       	brcc	.+8      	; 0x9ea <main+0x3de>
						Setup++;
 9e2:	8f 5f       	subi	r24, 0xFF	; 255
 9e4:	80 93 6a 00 	sts	0x006A, r24
 9e8:	b8 c0       	rjmp	.+368    	; 0xb5a <main+0x54e>
					else {
						Setup--;
 9ea:	81 50       	subi	r24, 0x01	; 1
 9ec:	80 93 6a 00 	sts	0x006A, r24
						FlashLED(5, 1, 1);
 9f0:	41 e0       	ldi	r20, 0x01	; 1
 9f2:	61 e0       	ldi	r22, 0x01	; 1
 9f4:	85 e0       	ldi	r24, 0x05	; 5
 9f6:	4f db       	rcall	.-2402   	; 0x96 <FlashLED>
 9f8:	b0 c0       	rjmp	.+352    	; 0xb5a <main+0x54e>
					}
				} else {
					if(KeyOkTimeout == 0)
 9fa:	80 91 6f 00 	lds	r24, 0x006F
 9fe:	81 11       	cpse	r24, r1
 a00:	03 c0       	rjmp	.+6      	; 0xa08 <main+0x3fc>
						KeyOkTimeout = 5; // 0.6 sec wait for the next Ok pressing
 a02:	f0 92 6f 00 	sts	0x006F, r15
 a06:	a9 c0       	rjmp	.+338    	; 0xb5a <main+0x54e>
					else { // Ok was pressed 2 times within 0.5 sec
						KeyOkTimeout = 0;
 a08:	10 92 6f 00 	sts	0x006F, r1
						FlashLED(10, 1, 1);
 a0c:	41 e0       	ldi	r20, 0x01	; 1
 a0e:	61 e0       	ldi	r22, 0x01	; 1
 a10:	8a e0       	ldi	r24, 0x0A	; 10
 a12:	41 db       	rcall	.-2430   	; 0x96 <FlashLED>
						Setup = 1;
 a14:	00 93 6a 00 	sts	0x006A, r16
						LED_Warning = SetupItem = 1; // setup item
 a18:	00 93 7a 00 	sts	0x007A, r16
 a1c:	11 c0       	rjmp	.+34     	; 0xa40 <main+0x434>
						Timer = 255; // ~32 sec
					}
				}
				break;
			} case IRKey_FanOverride: {
				if(Setup == 0) {
 a1e:	90 91 6a 00 	lds	r25, 0x006A
 a22:	91 11       	cpse	r25, r1
 a24:	10 c0       	rjmp	.+32     	; 0xa46 <main+0x43a>
					FlashLED(3, 1, 1);
 a26:	41 e0       	ldi	r20, 0x01	; 1
 a28:	61 e0       	ldi	r22, 0x01	; 1
 a2a:	83 e0       	ldi	r24, 0x03	; 3
 a2c:	34 db       	rcall	.-2456   	; 0x96 <FlashLED>
					Setup = 2;
 a2e:	82 e0       	ldi	r24, 0x02	; 2
 a30:	80 93 6a 00 	sts	0x006A, r24
					SetupItem = 4;
 a34:	c0 93 7a 00 	sts	0x007A, r28
					SetupType = 0;
 a38:	10 92 86 00 	sts	0x0086, r1
					LED_Warning = datapos = 1;
 a3c:	00 93 69 00 	sts	0x0069, r16
 a40:	00 93 74 00 	sts	0x0074, r16
 a44:	31 c0       	rjmp	.+98     	; 0xaa8 <main+0x49c>
					Timer = 255; // ~32 sec
				} else if(SetupItem == 3) { // EEPROM edit
 a46:	80 91 7a 00 	lds	r24, 0x007A
 a4a:	83 30       	cpi	r24, 0x03	; 3
 a4c:	51 f4       	brne	.+20     	; 0xa62 <main+0x456>
					if(Setup == 2) LED_Warning = (datapos += 0x10); else LED_Warning = (data += 10); // add 0x10 to pos, 10 to byte
 a4e:	92 30       	cpi	r25, 0x02	; 2
 a50:	21 f4       	brne	.+8      	; 0xa5a <main+0x44e>
 a52:	80 91 69 00 	lds	r24, 0x0069
 a56:	80 5f       	subi	r24, 0xF0	; 240
 a58:	07 cf       	rjmp	.-498    	; 0x868 <main+0x25c>
 a5a:	80 91 68 00 	lds	r24, 0x0068
 a5e:	86 5f       	subi	r24, 0xF6	; 246
 a60:	b3 ce       	rjmp	.-666    	; 0x7c8 <main+0x1bc>
				} else if(SetupItem == 4) { // Override menu item
 a62:	84 30       	cpi	r24, 0x04	; 4
 a64:	09 f0       	breq	.+2      	; 0xa68 <main+0x45c>
 a66:	71 c0       	rjmp	.+226    	; 0xb4a <main+0x53e>
					SetupType ^= 1; // switch mode Fan Override / Fan Force
 a68:	80 91 86 00 	lds	r24, 0x0086
 a6c:	8e 25       	eor	r24, r14
 a6e:	80 93 86 00 	sts	0x0086, r24
					FlashLED(SetupType ? 6 : 3, 1, 1);
 a72:	88 23       	and	r24, r24
 a74:	11 f0       	breq	.+4      	; 0xa7a <main+0x46e>
 a76:	86 e0       	ldi	r24, 0x06	; 6
 a78:	01 c0       	rjmp	.+2      	; 0xa7c <main+0x470>
 a7a:	83 e0       	ldi	r24, 0x03	; 3
 a7c:	41 e0       	ldi	r20, 0x01	; 1
 a7e:	61 e0       	ldi	r22, 0x01	; 1
 a80:	0a db       	rcall	.-2540   	; 0x96 <FlashLED>
					LED_Warning = 0;
 a82:	10 92 74 00 	sts	0x0074, r1
					Delay100ms(5);
 a86:	85 e0       	ldi	r24, 0x05	; 5
 a88:	90 e0       	ldi	r25, 0x00	; 0
 a8a:	f7 da       	rcall	.-2578   	; 0x7a <Delay100ms>
					ShowFanSpeedOverride(SetupType ? FanSpeedForce[datapos - 1] : FanSpeedOverrideArray[datapos - 1]);
 a8c:	80 91 86 00 	lds	r24, 0x0086
 a90:	e0 91 69 00 	lds	r30, 0x0069
 a94:	f0 e0       	ldi	r31, 0x00	; 0
 a96:	88 23       	and	r24, r24
 a98:	19 f0       	breq	.+6      	; 0xaa0 <main+0x494>
 a9a:	e4 57       	subi	r30, 0x74	; 116
 a9c:	ff 4f       	sbci	r31, 0xFF	; 255
 a9e:	02 c0       	rjmp	.+4      	; 0xaa4 <main+0x498>
 aa0:	e6 58       	subi	r30, 0x86	; 134
 aa2:	ff 4f       	sbci	r31, 0xFF	; 255
 aa4:	80 81       	ld	r24, Z
 aa6:	a0 dd       	rcall	.-1216   	; 0x5e8 <ShowFanSpeedOverride>
					Timer = 255; // ~32 sec
 aa8:	10 93 61 00 	sts	0x0061, r17
 aac:	56 c0       	rjmp	.+172    	; 0xb5a <main+0x54e>
				EEPROM_write(EPROM_OSCCAL, OSCCAL);
				TCCR0A &= ~(1<<COM0B1);
				DDRA &= ~(1<<PORTA7); // in
				continue;
			}
			SetupIR = 0;
 aae:	10 92 6b 00 	sts	0x006B, r1
				if(IRReceived == IRIsCommandReceived) {
					if(SetupIR == 1) EEPROM_write(EPROM_IRCommandHead - 1 + SetupIR, IRHead);
					EEPROM_write(EPROM_IRCommandArray + (SetupIR-1) * sizeof(IRHash), (uint8_t) (IRHash % 256));
					EEPROM_write(EPROM_IRCommandArray + (SetupIR-1) * sizeof(IRHash) + 1, (uint8_t) (IRHash / 256));
					if(SetupIR < IRCommands) {
xSetupIR:				SetupIR++;
 ab2:	80 91 6b 00 	lds	r24, 0x006B
 ab6:	8f 5f       	subi	r24, 0xFF	; 255
 ab8:	80 93 6b 00 	sts	0x006B, r24
						FlashLED(3, 1, 1);
 abc:	41 e0       	ldi	r20, 0x01	; 1
 abe:	61 e0       	ldi	r22, 0x01	; 1
 ac0:	83 e0       	ldi	r24, 0x03	; 3
 ac2:	e9 da       	rcall	.-2606   	; 0x96 <FlashLED>
						LED_Warning = SetupIR;
 ac4:	80 91 6b 00 	lds	r24, 0x006B
 ac8:	80 93 74 00 	sts	0x0074, r24
						Delay100ms(15);
 acc:	8f e0       	ldi	r24, 0x0F	; 15
 ace:	90 e0       	ldi	r25, 0x00	; 0
 ad0:	d4 da       	rcall	.-2648   	; 0x7a <Delay100ms>
						IRReceived = 0;
 ad2:	10 92 6d 00 	sts	0x006D, r1
						Timer = 255;
 ad6:	10 93 61 00 	sts	0x0061, r17
					} else {
						FlashLED(8, 1, 1);
						break;
					}
				}
			} while(Timer);
 ada:	80 91 61 00 	lds	r24, 0x0061
 ade:	88 23       	and	r24, r24
 ae0:	19 f1       	breq	.+70     	; 0xb28 <main+0x51c>
			}
			SetupIR = 0;
			goto xSetupIR;
			do {
				__asm__ volatile ("" ::: "memory"); // Need memory barrier
				sleep_cpu();
 ae2:	88 95       	sleep
				if(IRReceived == IRIsCommandReceived) {
 ae4:	80 91 6d 00 	lds	r24, 0x006D
 ae8:	83 30       	cpi	r24, 0x03	; 3
 aea:	b9 f7       	brne	.-18     	; 0xada <main+0x4ce>
					if(SetupIR == 1) EEPROM_write(EPROM_IRCommandHead - 1 + SetupIR, IRHead);
 aec:	80 91 6b 00 	lds	r24, 0x006B
 af0:	81 30       	cpi	r24, 0x01	; 1
 af2:	21 f4       	brne	.+8      	; 0xafc <main+0x4f0>
 af4:	60 91 76 00 	lds	r22, 0x0076
 af8:	80 e3       	ldi	r24, 0x30	; 48
 afa:	ef da       	rcall	.-2594   	; 0xda <EEPROM_write>
					EEPROM_write(EPROM_IRCommandArray + (SetupIR-1) * sizeof(IRHash), (uint8_t) (IRHash % 256));
 afc:	80 91 6b 00 	lds	r24, 0x006B
 b00:	88 0f       	add	r24, r24
 b02:	60 91 78 00 	lds	r22, 0x0078
 b06:	81 5d       	subi	r24, 0xD1	; 209
 b08:	e8 da       	rcall	.-2608   	; 0xda <EEPROM_write>
					EEPROM_write(EPROM_IRCommandArray + (SetupIR-1) * sizeof(IRHash) + 1, (uint8_t) (IRHash / 256));
 b0a:	60 91 79 00 	lds	r22, 0x0079
 b0e:	80 91 6b 00 	lds	r24, 0x006B
 b12:	88 0f       	add	r24, r24
 b14:	80 5d       	subi	r24, 0xD0	; 208
 b16:	e1 da       	rcall	.-2622   	; 0xda <EEPROM_write>
					if(SetupIR < IRCommands) {
 b18:	80 91 6b 00 	lds	r24, 0x006B
 b1c:	84 30       	cpi	r24, 0x04	; 4
 b1e:	48 f2       	brcs	.-110    	; 0xab2 <main+0x4a6>
						LED_Warning = SetupIR;
						Delay100ms(15);
						IRReceived = 0;
						Timer = 255;
					} else {
						FlashLED(8, 1, 1);
 b20:	41 e0       	ldi	r20, 0x01	; 1
 b22:	61 e0       	ldi	r22, 0x01	; 1
 b24:	88 e0       	ldi	r24, 0x08	; 8
 b26:	b7 da       	rcall	.-2706   	; 0x96 <FlashLED>
						break;
					}
				}
			} while(Timer);
			IRReceived = 0;
 b28:	10 92 6d 00 	sts	0x006D, r1
			Key1Pressed = 0;
 b2c:	10 92 6c 00 	sts	0x006C, r1
			SetupIR = 0;
 b30:	10 92 6b 00 	sts	0x006B, r1
			LED_Warning = 0;
 b34:	10 92 74 00 	sts	0x0074, r1
		}
		if(Timer == 0)
 b38:	80 91 61 00 	lds	r24, 0x0061
 b3c:	81 11       	cpse	r24, r1
 b3e:	ef cd       	rjmp	.-1058   	; 0x71e <main+0x112>
		{
			uint16_t co2;
			if(Setup) goto xSetupExit;
 b40:	80 91 6a 00 	lds	r24, 0x006A
 b44:	88 23       	and	r24, r24
 b46:	09 f4       	brne	.+2      	; 0xb4a <main+0x53e>
 b48:	4c c0       	rjmp	.+152    	; 0xbe2 <main+0x5d6>
					LED_Warning = 0;
					Delay100ms(5);
					ShowFanSpeedOverride(SetupType ? FanSpeedForce[datapos - 1] : FanSpeedOverrideArray[datapos - 1]);
					Timer = 255; // ~32 sec
				} else {
xSetupExit:			Setup = 0;
 b4a:	10 92 6a 00 	sts	0x006A, r1
					SetupItem = 0;
 b4e:	10 92 7a 00 	sts	0x007A, r1
					LED_Warning = 0;
 b52:	10 92 74 00 	sts	0x0074, r1
					Timer = 0;
 b56:	10 92 61 00 	sts	0x0061, r1
				}
				break;
			}
		}
		if(KeyOkTimeout == 1) { // Reseting single time Ok pressed
 b5a:	80 91 6f 00 	lds	r24, 0x006F
 b5e:	81 30       	cpi	r24, 0x01	; 1
 b60:	31 f4       	brne	.+12     	; 0xb6e <main+0x562>
			FanSpeedOverride = 0;
 b62:	10 92 70 00 	sts	0x0070, r1
			FlashLED(5, 1, 1);
 b66:	41 e0       	ldi	r20, 0x01	; 1
 b68:	61 e0       	ldi	r22, 0x01	; 1
 b6a:	85 e0       	ldi	r24, 0x05	; 5
 b6c:	94 da       	rcall	.-2776   	; 0x96 <FlashLED>
		}
		if(Key1Pressed == 255) // Press and hold key1 for ~3.2 sec
 b6e:	80 91 6c 00 	lds	r24, 0x006C
 b72:	8f 3f       	cpi	r24, 0xFF	; 255
 b74:	09 f7       	brne	.-62     	; 0xb38 <main+0x52c>
		{	// Setup IR Commands (2 (after 3.2s) and 7 short flashed will indicate it):
			FlashLED(2, 1, 1);
 b76:	41 e0       	ldi	r20, 0x01	; 1
 b78:	61 e0       	ldi	r22, 0x01	; 1
 b7a:	82 e0       	ldi	r24, 0x02	; 2
 b7c:	8c da       	rcall	.-2792   	; 0x96 <FlashLED>
			Key1Pressed = 0;
 b7e:	10 92 6c 00 	sts	0x006C, r1
			do { Delay100ms(1); } while(KEY1_PRESSING);
 b82:	81 e0       	ldi	r24, 0x01	; 1
 b84:	90 e0       	ldi	r25, 0x00	; 0
 b86:	79 da       	rcall	.-2830   	; 0x7a <Delay100ms>
 b88:	b2 9b       	sbis	0x16, 2	; 22
 b8a:	fb cf       	rjmp	.-10     	; 0xb82 <main+0x576>
			if(Key1Pressed == 255) { // + ~3.2 sec
 b8c:	80 91 6c 00 	lds	r24, 0x006C
 b90:	8f 3f       	cpi	r24, 0xFF	; 255
 b92:	09 f0       	breq	.+2      	; 0xb96 <main+0x58a>
 b94:	8c cf       	rjmp	.-232    	; 0xaae <main+0x4a2>
				// Set OSCCAL. Freq out 20480 Hz -> OC0B (pin 6).
				OCR0B = (OCR0A + 1) / 2 - 1; // Half Duty cycle = ((TOP+1)/2-1)
 b96:	86 b7       	in	r24, 0x36	; 54
 b98:	90 e0       	ldi	r25, 0x00	; 0
 b9a:	01 96       	adiw	r24, 0x01	; 1
 b9c:	95 95       	asr	r25
 b9e:	87 95       	ror	r24
 ba0:	81 50       	subi	r24, 0x01	; 1
 ba2:	8c bf       	out	0x3c, r24	; 60
				TCCR0A |= (1<<COM0B1);  // Freq out: pin OC0B
 ba4:	80 b7       	in	r24, 0x30	; 48
 ba6:	80 62       	ori	r24, 0x20	; 32
 ba8:	80 bf       	out	0x30, r24	; 48
				DDRA |= (1<<PORTA7); // out
 baa:	d7 9a       	sbi	0x1a, 7	; 26
								FlashLED(1, 1, 1);
							} else {
								OSCCAL--;
								FlashLED(2, 1, 1);
							}
xSetupOSCCAL:				Key1Pressed = 0;
 bac:	10 92 6c 00 	sts	0x006C, r1
							Timer = 255;
 bb0:	10 93 61 00 	sts	0x0061, r17
 bb4:	a5 cd       	rjmp	.-1206   	; 0x700 <main+0xf4>
				do {
					__asm__ volatile ("" ::: "memory"); // Need memory barrier
					LED1_ON;
					sleep_cpu();
					if(!KEY1_PRESSING) {
						if(Key1Pressed > 2) {
 bb6:	80 91 6c 00 	lds	r24, 0x006C
 bba:	83 30       	cpi	r24, 0x03	; 3
 bbc:	08 f4       	brcc	.+2      	; 0xbc0 <main+0x5b4>
 bbe:	a0 cd       	rjmp	.-1216   	; 0x700 <main+0xf4>
							if(Key1Pressed < 80) { // ~ 1 sec
 bc0:	80 35       	cpi	r24, 0x50	; 80
 bc2:	38 f4       	brcc	.+14     	; 0xbd2 <main+0x5c6>
								OSCCAL++;
 bc4:	81 b7       	in	r24, 0x31	; 49
 bc6:	8f 5f       	subi	r24, 0xFF	; 255
 bc8:	81 bf       	out	0x31, r24	; 49
								FlashLED(1, 1, 1);
 bca:	41 e0       	ldi	r20, 0x01	; 1
 bcc:	61 e0       	ldi	r22, 0x01	; 1
 bce:	81 e0       	ldi	r24, 0x01	; 1
 bd0:	06 c0       	rjmp	.+12     	; 0xbde <main+0x5d2>
							} else {
								OSCCAL--;
 bd2:	81 b7       	in	r24, 0x31	; 49
 bd4:	81 50       	subi	r24, 0x01	; 1
 bd6:	81 bf       	out	0x31, r24	; 49
								FlashLED(2, 1, 1);
 bd8:	41 e0       	ldi	r20, 0x01	; 1
 bda:	61 e0       	ldi	r22, 0x01	; 1
 bdc:	82 e0       	ldi	r24, 0x02	; 2
 bde:	5b da       	rcall	.-2890   	; 0x96 <FlashLED>
 be0:	e5 cf       	rjmp	.-54     	; 0xbac <main+0x5a0>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 be2:	f8 94       	cli
		{
			uint16_t co2;
			if(Setup) goto xSetupExit;
xSendNow:
			ATOMIC_BLOCK(ATOMIC_FORCEON) {
				co2 = CO2Level;
 be4:	c0 91 71 00 	lds	r28, 0x0071
 be8:	d0 91 72 00 	lds	r29, 0x0072
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
 bec:	78 94       	sei
			}
			if(CO2LevelAverageCnt == 255) { // first time
 bee:	80 91 60 00 	lds	r24, 0x0060
 bf2:	8f 3f       	cpi	r24, 0xFF	; 255
 bf4:	69 f4       	brne	.+26     	; 0xc10 <main+0x604>
				for(i = 1; i < CO2LevelAverageArrayLength; i++)
					CO2LevelAverageArray[i] = co2;
 bf6:	d0 93 9a 00 	sts	0x009A, r29
 bfa:	c0 93 99 00 	sts	0x0099, r28
 bfe:	d0 93 9c 00 	sts	0x009C, r29
 c02:	c0 93 9b 00 	sts	0x009B, r28
 c06:	d0 93 9e 00 	sts	0x009E, r29
 c0a:	c0 93 9d 00 	sts	0x009D, r28
 c0e:	02 c0       	rjmp	.+4      	; 0xc14 <main+0x608>
			}
			if(CO2LevelAverageCnt >= CO2LevelAverageArrayLength) CO2LevelAverageCnt = 0;
 c10:	84 30       	cpi	r24, 0x04	; 4
 c12:	10 f0       	brcs	.+4      	; 0xc18 <main+0x60c>
 c14:	10 92 60 00 	sts	0x0060, r1
			CO2LevelAverageArray[CO2LevelAverageCnt++] = co2;
 c18:	e0 91 60 00 	lds	r30, 0x0060
 c1c:	81 e0       	ldi	r24, 0x01	; 1
 c1e:	8e 0f       	add	r24, r30
 c20:	80 93 60 00 	sts	0x0060, r24
 c24:	f0 e0       	ldi	r31, 0x00	; 0
 c26:	ee 0f       	add	r30, r30
 c28:	ff 1f       	adc	r31, r31
 c2a:	e9 56       	subi	r30, 0x69	; 105
 c2c:	ff 4f       	sbci	r31, 0xFF	; 255
 c2e:	d1 83       	std	Z+1, r29	; 0x01
 c30:	c0 83       	st	Z, r28
			uint16_t average = 0;
			for(i = 0; i < CO2LevelAverageArrayLength; i++)
				average += CO2LevelAverageArray[i];
 c32:	80 91 99 00 	lds	r24, 0x0099
 c36:	90 91 9a 00 	lds	r25, 0x009A
 c3a:	20 91 9b 00 	lds	r18, 0x009B
 c3e:	30 91 9c 00 	lds	r19, 0x009C
 c42:	82 0f       	add	r24, r18
 c44:	93 1f       	adc	r25, r19
 c46:	20 91 9d 00 	lds	r18, 0x009D
 c4a:	30 91 9e 00 	lds	r19, 0x009E
 c4e:	82 0f       	add	r24, r18
 c50:	93 1f       	adc	r25, r19
 c52:	20 91 97 00 	lds	r18, 0x0097
 c56:	30 91 98 00 	lds	r19, 0x0098
 c5a:	82 0f       	add	r24, r18
 c5c:	93 1f       	adc	r25, r19
			uint8_t average1b = (average /= CO2LevelAverageArrayLength) / 16; 
 c5e:	76 e0       	ldi	r23, 0x06	; 6
 c60:	96 95       	lsr	r25
 c62:	87 95       	ror	r24
 c64:	7a 95       	dec	r23
 c66:	e1 f7       	brne	.-8      	; 0xc60 <main+0x654>
 c68:	c8 2e       	mov	r12, r24
			int8_t fanspeed = 0;
 c6a:	d1 2c       	mov	r13, r1
			static int8_t fanspeed_prev = 0;
			for(; fanspeed < FanSpeedMax; fanspeed++) {
				uint8_t t = EEPROM_read(EPROM_FanSpeedThreshold + fanspeed);
 c6c:	80 e1       	ldi	r24, 0x10	; 16
 c6e:	8d 0d       	add	r24, r13
 c70:	2c da       	rcall	.-2984   	; 0xca <EEPROM_read>
				if(average1b < t) { 
 c72:	c8 16       	cp	r12, r24
 c74:	28 f0       	brcs	.+10     	; 0xc80 <main+0x674>
 c76:	d3 94       	inc	r13
			for(i = 0; i < CO2LevelAverageArrayLength; i++)
				average += CO2LevelAverageArray[i];
			uint8_t average1b = (average /= CO2LevelAverageArrayLength) / 16; 
			int8_t fanspeed = 0;
			static int8_t fanspeed_prev = 0;
			for(; fanspeed < FanSpeedMax; fanspeed++) {
 c78:	e6 e0       	ldi	r30, 0x06	; 6
 c7a:	de 12       	cpse	r13, r30
 c7c:	f7 cf       	rjmp	.-18     	; 0xc6c <main+0x660>
 c7e:	0a c0       	rjmp	.+20     	; 0xc94 <main+0x688>
				uint8_t t = EEPROM_read(EPROM_FanSpeedThreshold + fanspeed);
				if(average1b < t) { 
					// if there is a decrease of CO2 level - check delta
					if(fanspeed_prev <= fanspeed || (uint8_t)(t - average1b) >= EEPROM_read(EPROM_FanSpeedDelta)) break; 
 c80:	90 91 62 00 	lds	r25, 0x0062
 c84:	d9 16       	cp	r13, r25
 c86:	34 f4       	brge	.+12     	; 0xc94 <main+0x688>
 c88:	b8 2e       	mov	r11, r24
 c8a:	bc 18       	sub	r11, r12
 c8c:	86 e0       	ldi	r24, 0x06	; 6
 c8e:	1d da       	rcall	.-3014   	; 0xca <EEPROM_read>
 c90:	b8 16       	cp	r11, r24
 c92:	88 f3       	brcs	.-30     	; 0xc76 <main+0x66a>
				}
			}
			fanspeed_prev = fanspeed;
 c94:	d0 92 62 00 	sts	0x0062, r13
			if((fanspeed += FanSpeedOverride) > FanSpeedMax) fanspeed = FanSpeedMax;
 c98:	80 90 70 00 	lds	r8, 0x0070
 c9c:	8d 0c       	add	r8, r13
 c9e:	f6 e0       	ldi	r31, 0x06	; 6
 ca0:	f8 15       	cp	r31, r8
 ca2:	24 f0       	brlt	.+8      	; 0xcac <main+0x6a0>
			if(fanspeed < 0) fanspeed = 0;
 ca4:	87 fe       	sbrs	r8, 7
 ca6:	04 c0       	rjmp	.+8      	; 0xcb0 <main+0x6a4>
 ca8:	81 2c       	mov	r8, r1
 caa:	02 c0       	rjmp	.+4      	; 0xcb0 <main+0x6a4>
					// if there is a decrease of CO2 level - check delta
					if(fanspeed_prev <= fanspeed || (uint8_t)(t - average1b) >= EEPROM_read(EPROM_FanSpeedDelta)) break; 
				}
			}
			fanspeed_prev = fanspeed;
			if((fanspeed += FanSpeedOverride) > FanSpeedMax) fanspeed = FanSpeedMax;
 cac:	56 e0       	ldi	r21, 0x06	; 6
 cae:	85 2e       	mov	r8, r21
			if(fanspeed < 0) fanspeed = 0;
			if(LowLight && fanspeed > (int8_t)(i = EEPROM_read(EPROM_LowLightMaxFanSpeed))) fanspeed = i;
 cb0:	80 91 73 00 	lds	r24, 0x0073
 cb4:	88 23       	and	r24, r24
 cb6:	29 f0       	breq	.+10     	; 0xcc2 <main+0x6b6>
 cb8:	84 e0       	ldi	r24, 0x04	; 4
 cba:	07 da       	rcall	.-3058   	; 0xca <EEPROM_read>
 cbc:	88 15       	cp	r24, r8
 cbe:	0c f4       	brge	.+2      	; 0xcc2 <main+0x6b6>
 cc0:	88 2e       	mov	r8, r24
			//NRF24_SetMode(NRF24_TransmitMode);
			uint8_t maxfans = EEPROM_read(EPROM_NumberFans);
 cc2:	82 e0       	ldi	r24, 0x02	; 2
 cc4:	02 da       	rcall	.-3068   	; 0xca <EEPROM_read>
 cc6:	48 2e       	mov	r4, r24
 cc8:	3b e7       	ldi	r19, 0x7B	; 123
 cca:	a3 2e       	mov	r10, r19
 ccc:	30 e0       	ldi	r19, 0x00	; 0
 cce:	b3 2e       	mov	r11, r19
			for(uint8_t fan = 0; fan < maxfans; fan++)
 cd0:	4d e8       	ldi	r20, 0x8D	; 141
 cd2:	c4 2e       	mov	r12, r20
 cd4:	40 e0       	ldi	r20, 0x00	; 0
 cd6:	d4 2e       	mov	r13, r20
 cd8:	61 2c       	mov	r6, r1
 cda:	64 14       	cp	r6, r4
 cdc:	09 f4       	brne	.+2      	; 0xce0 <main+0x6d4>
 cde:	7f c0       	rjmp	.+254    	; 0xdde <main+0x7d2>
			{
				if(maxfans > 1) {
 ce0:	81 e0       	ldi	r24, 0x01	; 1
 ce2:	84 15       	cp	r24, r4
 ce4:	48 f4       	brcc	.+18     	; 0xcf8 <main+0x6ec>
					if(!NRF24_SetAddresses(EEPROM_read(EPROM_RFAddresses + fan)))
 ce6:	80 e2       	ldi	r24, 0x20	; 32
 ce8:	86 0d       	add	r24, r6
 cea:	ef d9       	rcall	.-3106   	; 0xca <EEPROM_read>
 cec:	94 da       	rcall	.-2776   	; 0x216 <NRF24_SetAddresses>
 cee:	81 11       	cpse	r24, r1
 cf0:	03 c0       	rjmp	.+6      	; 0xcf8 <main+0x6ec>
					{
						Set_LED_Warning(ERR_RF_SetAddr);
 cf2:	80 e2       	ldi	r24, 0x20	; 32
 cf4:	6b dc       	rcall	.-1834   	; 0x5cc <Set_LED_Warning>
						break;
 cf6:	73 c0       	rjmp	.+230    	; 0xdde <main+0x7d2>
					}
				}
				int8_t fspeed = fanspeed + FanSpeedOverrideArray[fan];
 cf8:	f5 01       	movw	r30, r10
 cfa:	71 90       	ld	r7, Z+
 cfc:	5f 01       	movw	r10, r30
 cfe:	78 0c       	add	r7, r8
				if(fspeed > FanSpeedMax) fspeed = FanSpeedMax;
 d00:	f6 e0       	ldi	r31, 0x06	; 6
 d02:	f7 15       	cp	r31, r7
 d04:	24 f0       	brlt	.+8      	; 0xd0e <main+0x702>
				if(fspeed < 0) fspeed = 0;
 d06:	77 fe       	sbrs	r7, 7
 d08:	04 c0       	rjmp	.+8      	; 0xd12 <main+0x706>
 d0a:	71 2c       	mov	r7, r1
 d0c:	02 c0       	rjmp	.+4      	; 0xd12 <main+0x706>
						Set_LED_Warning(ERR_RF_SetAddr);
						break;
					}
				}
				int8_t fspeed = fanspeed + FanSpeedOverrideArray[fan];
				if(fspeed > FanSpeedMax) fspeed = FanSpeedMax;
 d0e:	26 e0       	ldi	r18, 0x06	; 6
 d10:	72 2e       	mov	r7, r18
				if(fspeed < 0) fspeed = 0;
				uint8_t RF_Changed = 0;
 d12:	31 2c       	mov	r3, r1
				i = EPROM_FanSpeedChangeArray;
 d14:	90 e4       	ldi	r25, 0x40	; 64
 d16:	99 2e       	mov	r9, r25
				do {
					uint8_t j = EEPROM_read(i++);
 d18:	55 24       	eor	r5, r5
 d1a:	53 94       	inc	r5
 d1c:	59 0c       	add	r5, r9
 d1e:	89 2d       	mov	r24, r9
 d20:	d4 d9       	rcall	.-3160   	; 0xca <EEPROM_read>
					if(j == fan) {
 d22:	86 11       	cpse	r24, r6
 d24:	20 c0       	rjmp	.+64     	; 0xd66 <main+0x75a>
						if((j = EEPROM_read(i++)) != 0xFF) { // Set RF channel
 d26:	82 e0       	ldi	r24, 0x02	; 2
 d28:	28 2e       	mov	r2, r24
 d2a:	29 0c       	add	r2, r9
 d2c:	85 2d       	mov	r24, r5
 d2e:	cd d9       	rcall	.-3174   	; 0xca <EEPROM_read>
 d30:	8f 3f       	cpi	r24, 0xFF	; 255
 d32:	29 f0       	breq	.+10     	; 0xd3e <main+0x732>
							NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH,	j);
 d34:	68 2f       	mov	r22, r24
 d36:	85 e2       	ldi	r24, 0x25	; 37
 d38:	08 da       	rcall	.-3056   	; 0x14a <NRF24_WriteByte>
							RF_Changed = 1;
 d3a:	33 24       	eor	r3, r3
 d3c:	33 94       	inc	r3
						}
						for(j = EEPROM_read(i++); j > 0; j--) { // Change speed if needed
 d3e:	83 e0       	ldi	r24, 0x03	; 3
 d40:	98 0e       	add	r9, r24
 d42:	82 2d       	mov	r24, r2
 d44:	c2 d9       	rcall	.-3196   	; 0xca <EEPROM_read>
 d46:	58 2e       	mov	r5, r24
 d48:	55 20       	and	r5, r5
 d4a:	31 f3       	breq	.-52     	; 0xd18 <main+0x70c>
							if((uint8_t) fspeed == EEPROM_read(i++)) {
 d4c:	89 2d       	mov	r24, r9
 d4e:	bd d9       	rcall	.-3206   	; 0xca <EEPROM_read>
 d50:	78 12       	cpse	r7, r24
 d52:	05 c0       	rjmp	.+10     	; 0xd5e <main+0x752>
								fspeed = EEPROM_read(i);
 d54:	81 e0       	ldi	r24, 0x01	; 1
 d56:	89 0d       	add	r24, r9
 d58:	b8 d9       	rcall	.-3216   	; 0xca <EEPROM_read>
 d5a:	78 2e       	mov	r7, r24
								goto xSkipArrayEnd;
 d5c:	0f c0       	rjmp	.+30     	; 0xd7c <main+0x770>
							} else i++;
 d5e:	93 94       	inc	r9
 d60:	93 94       	inc	r9
					if(j == fan) {
						if((j = EEPROM_read(i++)) != 0xFF) { // Set RF channel
							NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH,	j);
							RF_Changed = 1;
						}
						for(j = EEPROM_read(i++); j > 0; j--) { // Change speed if needed
 d62:	5a 94       	dec	r5
 d64:	f1 cf       	rjmp	.-30     	; 0xd48 <main+0x73c>
							if((uint8_t) fspeed == EEPROM_read(i++)) {
								fspeed = EEPROM_read(i);
								goto xSkipArrayEnd;
							} else i++;
						}
					} else if(j == 0xFF) { 
 d66:	8f 3f       	cpi	r24, 0xFF	; 255
 d68:	49 f0       	breq	.+18     	; 0xd7c <main+0x770>
						break;
					} else i += EEPROM_read(i + 1) * 2 + 2;
 d6a:	82 e0       	ldi	r24, 0x02	; 2
 d6c:	89 0d       	add	r24, r9
 d6e:	ad d9       	rcall	.-3238   	; 0xca <EEPROM_read>
 d70:	98 2e       	mov	r9, r24
 d72:	99 0c       	add	r9, r9
 d74:	93 94       	inc	r9
 d76:	93 94       	inc	r9
 d78:	95 0c       	add	r9, r5
 d7a:	ce cf       	rjmp	.-100    	; 0xd18 <main+0x70c>
				} while(1);
xSkipArrayEnd:
				((send_data*) &NRF24_Buffer)->CO2level = co2;
 d7c:	d0 93 89 00 	sts	0x0089, r29
 d80:	c0 93 88 00 	sts	0x0088, r28
				((send_data*) &NRF24_Buffer)->FanSpeed = FanSpeedForce[fan] != -1 ? FanSpeedForce[fan] : fspeed;
 d84:	f6 01       	movw	r30, r12
 d86:	81 91       	ld	r24, Z+
 d88:	6f 01       	movw	r12, r30
 d8a:	8f 3f       	cpi	r24, 0xFF	; 255
 d8c:	09 f0       	breq	.+2      	; 0xd90 <main+0x784>
 d8e:	78 2e       	mov	r7, r24
 d90:	70 92 8a 00 	sts	0x008A, r7
				((send_data*) &NRF24_Buffer)->Flags = LowLight;
 d94:	80 91 73 00 	lds	r24, 0x0073
 d98:	80 93 8b 00 	sts	0x008B, r24
				uint8_t err = NRF24_Transmit(NRF24_Buffer);
 d9c:	88 e8       	ldi	r24, 0x88	; 136
 d9e:	90 e0       	ldi	r25, 0x00	; 0
 da0:	18 da       	rcall	.-3024   	; 0x1d2 <NRF24_Transmit>
 da2:	98 2e       	mov	r9, r24
				if(RF_Changed) NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH, EEPROM_read(EPROM_RF_Channel)); // restore RF channel
 da4:	33 20       	and	r3, r3
 da6:	29 f0       	breq	.+10     	; 0xdb2 <main+0x7a6>
 da8:	87 e0       	ldi	r24, 0x07	; 7
 daa:	8f d9       	rcall	.-3298   	; 0xca <EEPROM_read>
 dac:	68 2f       	mov	r22, r24
 dae:	85 e2       	ldi	r24, 0x25	; 37
 db0:	cc d9       	rcall	.-3176   	; 0x14a <NRF24_WriteByte>
				uint8_t err2 = err == 2 ? ERR_RF_NotResp : (ERR_RF_Send + fan + 1);
 db2:	f2 e0       	ldi	r31, 0x02	; 2
 db4:	9f 16       	cp	r9, r31
 db6:	29 f0       	breq	.+10     	; 0xdc2 <main+0x7b6>
				if(err)	{
 db8:	99 20       	and	r9, r9
 dba:	79 f0       	breq	.+30     	; 0xdda <main+0x7ce>
				((send_data*) &NRF24_Buffer)->CO2level = co2;
				((send_data*) &NRF24_Buffer)->FanSpeed = FanSpeedForce[fan] != -1 ? FanSpeedForce[fan] : fspeed;
				((send_data*) &NRF24_Buffer)->Flags = LowLight;
				uint8_t err = NRF24_Transmit(NRF24_Buffer);
				if(RF_Changed) NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH, EEPROM_read(EPROM_RF_Channel)); // restore RF channel
				uint8_t err2 = err == 2 ? ERR_RF_NotResp : (ERR_RF_Send + fan + 1);
 dbc:	81 e1       	ldi	r24, 0x11	; 17
 dbe:	86 0d       	add	r24, r6
 dc0:	01 c0       	rjmp	.+2      	; 0xdc4 <main+0x7b8>
 dc2:	80 e3       	ldi	r24, 0x30	; 48
				if(err)	{
					Set_LED_Warning(err2);
 dc4:	03 dc       	rcall	.-2042   	; 0x5cc <Set_LED_Warning>
					NRF24_SendCommand(NRF24_CMD_FLUSH_RX);
 dc6:	82 ee       	ldi	r24, 0xE2	; 226
 dc8:	f2 d9       	rcall	.-3100   	; 0x1ae <NRF24_SendCommand>
					NRF24_SendCommand(NRF24_CMD_FLUSH_TX);
 dca:	81 ee       	ldi	r24, 0xE1	; 225
 dcc:	f0 d9       	rcall	.-3104   	; 0x1ae <NRF24_SendCommand>
					NRF24_Powerdown();
 dce:	44 da       	rcall	.-2936   	; 0x258 <NRF24_Powerdown>
					Delay100ms(20); // 2 sec
 dd0:	84 e1       	ldi	r24, 0x14	; 20
 dd2:	90 e0       	ldi	r25, 0x00	; 0
 dd4:	52 d9       	rcall	.-3420   	; 0x7a <Delay100ms>
					NRF24_SetMode(NRF24_TransmitMode);
 dd6:	80 e0       	ldi	r24, 0x00	; 0
 dd8:	ee d9       	rcall	.-3108   	; 0x1b6 <NRF24_SetMode>
			if((fanspeed += FanSpeedOverride) > FanSpeedMax) fanspeed = FanSpeedMax;
			if(fanspeed < 0) fanspeed = 0;
			if(LowLight && fanspeed > (int8_t)(i = EEPROM_read(EPROM_LowLightMaxFanSpeed))) fanspeed = i;
			//NRF24_SetMode(NRF24_TransmitMode);
			uint8_t maxfans = EEPROM_read(EPROM_NumberFans);
			for(uint8_t fan = 0; fan < maxfans; fan++)
 dda:	63 94       	inc	r6
 ddc:	7e cf       	rjmp	.-260    	; 0xcda <main+0x6ce>
					Delay100ms(20); // 2 sec
					NRF24_SetMode(NRF24_TransmitMode);
				}
			}
			//NRF24_Powerdown();
			Timer = EEPROM_read(EPROM_TransmitPeriod);
 dde:	83 e0       	ldi	r24, 0x03	; 3
 de0:	74 d9       	rcall	.-3352   	; 0xca <EEPROM_read>
 de2:	80 93 61 00 	sts	0x0061, r24
 de6:	9b cc       	rjmp	.-1738   	; 0x71e <main+0x112>

00000de8 <memcpy_P>:
 de8:	fb 01       	movw	r30, r22
 dea:	dc 01       	movw	r26, r24
 dec:	02 c0       	rjmp	.+4      	; 0xdf2 <memcpy_P+0xa>
 dee:	05 90       	lpm	r0, Z+
 df0:	0d 92       	st	X+, r0
 df2:	41 50       	subi	r20, 0x01	; 1
 df4:	50 40       	sbci	r21, 0x00	; 0
 df6:	d8 f7       	brcc	.-10     	; 0xdee <memcpy_P+0x6>
 df8:	08 95       	ret

00000dfa <_exit>:
 dfa:	f8 94       	cli

00000dfc <__stop_program>:
 dfc:	ff cf       	rjmp	.-2      	; 0xdfc <__stop_program>
