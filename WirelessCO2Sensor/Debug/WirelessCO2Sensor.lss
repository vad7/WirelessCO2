
WirelessCO2Sensor.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000df8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  00000df8  00000e8c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000003e  00800062  00800062  00000e8e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e8e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000108  00000000  00000000  00000ebe  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000015d4  00000000  00000000  00000fc6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003aa  00000000  00000000  0000259a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000007ba  00000000  00000000  00002944  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000378  00000000  00000000  00003100  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000609  00000000  00000000  00003478  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001109  00000000  00000000  00003a81  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000178  00000000  00000000  00004b8a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	17 c0       	rjmp	.+46     	; 0x30 <__ctors_end>
   2:	31 c0       	rjmp	.+98     	; 0x66 <__bad_interrupt>
   4:	ca c1       	rjmp	.+916    	; 0x39a <__vector_2>
   6:	5e c2       	rjmp	.+1212   	; 0x4c4 <__vector_3>
   8:	3e c1       	rjmp	.+636    	; 0x286 <__vector_4>
   a:	2d c0       	rjmp	.+90     	; 0x66 <__bad_interrupt>
   c:	2c c0       	rjmp	.+88     	; 0x66 <__bad_interrupt>
   e:	2b c0       	rjmp	.+86     	; 0x66 <__bad_interrupt>
  10:	ee c1       	rjmp	.+988    	; 0x3ee <__vector_8>
  12:	29 c0       	rjmp	.+82     	; 0x66 <__bad_interrupt>
  14:	28 c0       	rjmp	.+80     	; 0x66 <__bad_interrupt>
  16:	05 c2       	rjmp	.+1034   	; 0x422 <__vector_11>
  18:	26 c0       	rjmp	.+76     	; 0x66 <__bad_interrupt>
  1a:	a6 c1       	rjmp	.+844    	; 0x368 <__vector_13>
  1c:	24 c0       	rjmp	.+72     	; 0x66 <__bad_interrupt>
  1e:	23 c0       	rjmp	.+70     	; 0x66 <__bad_interrupt>
  20:	22 c0       	rjmp	.+68     	; 0x66 <__bad_interrupt>

00000022 <NRF24_BASE_ADDR>:
  22:	c8 c8                                               ..

00000024 <NRF24_INIT_DATA>:
  24:	23 01 24 77 26 07 21 01 22 01 31 04                 #.$w&.!.".1.

00000030 <__ctors_end>:
  30:	11 24       	eor	r1, r1
  32:	1f be       	out	0x3f, r1	; 63
  34:	cf e5       	ldi	r28, 0x5F	; 95
  36:	d1 e0       	ldi	r29, 0x01	; 1
  38:	de bf       	out	0x3e, r29	; 62
  3a:	cd bf       	out	0x3d, r28	; 61

0000003c <__do_copy_data>:
  3c:	10 e0       	ldi	r17, 0x00	; 0
  3e:	a0 e6       	ldi	r26, 0x60	; 96
  40:	b0 e0       	ldi	r27, 0x00	; 0
  42:	e8 ef       	ldi	r30, 0xF8	; 248
  44:	fd e0       	ldi	r31, 0x0D	; 13
  46:	02 c0       	rjmp	.+4      	; 0x4c <__SREG__+0xd>
  48:	05 90       	lpm	r0, Z+
  4a:	0d 92       	st	X+, r0
  4c:	a2 36       	cpi	r26, 0x62	; 98
  4e:	b1 07       	cpc	r27, r17
  50:	d9 f7       	brne	.-10     	; 0x48 <__SREG__+0x9>

00000052 <__do_clear_bss>:
  52:	20 e0       	ldi	r18, 0x00	; 0
  54:	a2 e6       	ldi	r26, 0x62	; 98
  56:	b0 e0       	ldi	r27, 0x00	; 0
  58:	01 c0       	rjmp	.+2      	; 0x5c <.do_clear_bss_start>

0000005a <.do_clear_bss_loop>:
  5a:	1d 92       	st	X+, r1

0000005c <.do_clear_bss_start>:
  5c:	a0 3a       	cpi	r26, 0xA0	; 160
  5e:	b2 07       	cpc	r27, r18
  60:	e1 f7       	brne	.-8      	; 0x5a <.do_clear_bss_loop>
  62:	ed d2       	rcall	.+1498   	; 0x63e <main>
  64:	c7 c6       	rjmp	.+3470   	; 0xdf4 <_exit>

00000066 <__bad_interrupt>:
  66:	cc cf       	rjmp	.-104    	; 0x0 <__vectors>

00000068 <Delay10us>:
   uint8_t Flags; // // Mask: 0x80 - Setup command, 0x01 - Lowlight
} __attribute__ ((packed)) send_data;

#if(1)
void Delay10us(uint8_t ms) {
	while(ms-- > 0) _delay_us(10); //wdt_reset();
  68:	88 23       	and	r24, r24
  6a:	31 f0       	breq	.+12     	; 0x78 <Delay10us+0x10>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  6c:	9b e1       	ldi	r25, 0x1B	; 27
  6e:	9a 95       	dec	r25
  70:	f1 f7       	brne	.-4      	; 0x6e <Delay10us+0x6>
  72:	00 00       	nop
  74:	81 50       	subi	r24, 0x01	; 1
  76:	f8 cf       	rjmp	.-16     	; 0x68 <Delay10us>
}
  78:	08 95       	ret

0000007a <Delay100ms>:
	while(ms-- > 0) { 
		_delay_ms(1); //wdt_reset(); 
	}
}
void Delay100ms(unsigned int ms) {
	while(ms-- > 0) { 
  7a:	00 97       	sbiw	r24, 0x00	; 0
  7c:	59 f0       	breq	.+22     	; 0x94 <Delay100ms+0x1a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  7e:	2f ef       	ldi	r18, 0xFF	; 255
  80:	3f e7       	ldi	r19, 0x7F	; 127
  82:	42 e0       	ldi	r20, 0x02	; 2
  84:	21 50       	subi	r18, 0x01	; 1
  86:	30 40       	sbci	r19, 0x00	; 0
  88:	40 40       	sbci	r20, 0x00	; 0
  8a:	e1 f7       	brne	.-8      	; 0x84 <Delay100ms+0xa>
  8c:	00 c0       	rjmp	.+0      	; 0x8e <Delay100ms+0x14>
  8e:	00 00       	nop
  90:	01 97       	sbiw	r24, 0x01	; 1
  92:	f3 cf       	rjmp	.-26     	; 0x7a <Delay100ms>
		_delay_ms(100); //wdt_reset();
	}
}
  94:	08 95       	ret

00000096 <FlashLED>:

void FlashLED(uint8_t num, uint8_t toff, uint8_t ton) {
  96:	ff 92       	push	r15
  98:	0f 93       	push	r16
  9a:	1f 93       	push	r17
  9c:	cf 93       	push	r28
  9e:	df 93       	push	r29
	while (num-- > 0) {
  a0:	f8 2e       	mov	r15, r24
		LED1_OFF;
		Delay100ms(toff);
  a2:	06 2f       	mov	r16, r22
  a4:	10 e0       	ldi	r17, 0x00	; 0
		LED1_ON;
		Delay100ms(ton);
  a6:	c4 2f       	mov	r28, r20
  a8:	d0 e0       	ldi	r29, 0x00	; 0
	}
}

void FlashLED(uint8_t num, uint8_t toff, uint8_t ton) {
	while (num-- > 0) {
		LED1_OFF;
  aa:	d9 98       	cbi	0x1b, 1	; 27
		_delay_ms(100); //wdt_reset();
	}
}

void FlashLED(uint8_t num, uint8_t toff, uint8_t ton) {
	while (num-- > 0) {
  ac:	ff 20       	and	r15, r15
  ae:	39 f0       	breq	.+14     	; 0xbe <FlashLED+0x28>
		LED1_OFF;
		Delay100ms(toff);
  b0:	c8 01       	movw	r24, r16
  b2:	e3 df       	rcall	.-58     	; 0x7a <Delay100ms>
		LED1_ON;
  b4:	d9 9a       	sbi	0x1b, 1	; 27
		Delay100ms(ton);
  b6:	ce 01       	movw	r24, r28
  b8:	e0 df       	rcall	.-64     	; 0x7a <Delay100ms>
  ba:	fa 94       	dec	r15
  bc:	f6 cf       	rjmp	.-20     	; 0xaa <FlashLED+0x14>
	}
	LED1_OFF;
}
  be:	df 91       	pop	r29
  c0:	cf 91       	pop	r28
  c2:	1f 91       	pop	r17
  c4:	0f 91       	pop	r16
  c6:	ff 90       	pop	r15
  c8:	08 95       	ret

000000ca <EEPROM_read>:
	Delay100ms(20);
}

uint8_t EEPROM_read(uint8_t ucAddress) // ATtiny24A/44A only!
{
	while(EECR & (1<<EEPE)) ; // EEWE
  ca:	e1 99       	sbic	0x1c, 1	; 28
  cc:	fe cf       	rjmp	.-4      	; 0xca <EEPROM_read>
	EEAR = ucAddress;
  ce:	90 e0       	ldi	r25, 0x00	; 0
  d0:	9f bb       	out	0x1f, r25	; 31
  d2:	8e bb       	out	0x1e, r24	; 30
	EECR |= (1<<EERE);
  d4:	e0 9a       	sbi	0x1c, 0	; 28
	return EEDR;
  d6:	8d b3       	in	r24, 0x1d	; 29
}
  d8:	08 95       	ret

000000da <EEPROM_write>:
void EEPROM_write(uint8_t ucAddress, uint8_t ucData) // ATtiny24A/44A only!
{
	while(EECR & (1<<EEPE)) ; // EEWE
  da:	e1 99       	sbic	0x1c, 1	; 28
  dc:	fe cf       	rjmp	.-4      	; 0xda <EEPROM_write>
	cli();
  de:	f8 94       	cli
	EECR = (0<<EEPM1)|(0<<EEPM0);
  e0:	1c ba       	out	0x1c, r1	; 28
	EEAR = ucAddress;
  e2:	90 e0       	ldi	r25, 0x00	; 0
  e4:	9f bb       	out	0x1f, r25	; 31
  e6:	8e bb       	out	0x1e, r24	; 30
	EEDR = ucData;
  e8:	6d bb       	out	0x1d, r22	; 29
	EECR |= (1<<EEMPE); //(1<<EEMWE);
  ea:	e2 9a       	sbi	0x1c, 2	; 28
	EECR |= (1<<EEPE); //(1<<EEWE);
  ec:	e1 9a       	sbi	0x1c, 1	; 28
	sei();
  ee:	78 94       	sei
  f0:	08 95       	ret

000000f2 <SPI_WriteReadByte>:
	NRF24_CMD_W_REGISTER | NRF24_REG_RX_PW_P0,	NRF24_PAYLOAD_LEN
};
const uint8_t NRF24_BASE_ADDR[] PROGMEM = { 0xC8, 0xC8 }; // Address MSBs: 2..3

uint8_t SPI_WriteReadByte(uint8_t data) {
	USIDR = data;
  f2:	8f b9       	out	0x0f, r24	; 15
	USISR = (1<<USIOIF); // clear overflow flag
  f4:	80 e4       	ldi	r24, 0x40	; 64
  f6:	8e b9       	out	0x0e, r24	; 14
	do {
		USICR = (1<<USIWM0) | (1<<USICS1) | (1<<USICLK) | (1<<USITC);
  f8:	8b e1       	ldi	r24, 0x1B	; 27
  fa:	8d b9       	out	0x0d, r24	; 13
	} while((USISR & (1<<USIOIF)) == 0);
  fc:	76 9b       	sbis	0x0e, 6	; 14
  fe:	fd cf       	rjmp	.-6      	; 0xfa <SPI_WriteReadByte+0x8>
	return USIDR;
 100:	8f b1       	in	r24, 0x0f	; 15
}
 102:	08 95       	ret

00000104 <NRF24_ReadArray>:
	NRF24_SET_CSN_HI;
	return result;
}

void NRF24_ReadArray(uint8_t cmd, uint8_t *array, uint8_t len)
{
 104:	ef 92       	push	r14
 106:	ff 92       	push	r15
 108:	1f 93       	push	r17
 10a:	cf 93       	push	r28
 10c:	df 93       	push	r29
 10e:	00 d0       	rcall	.+0      	; 0x110 <NRF24_ReadArray+0xc>
 110:	cd b7       	in	r28, 0x3d	; 61
 112:	de b7       	in	r29, 0x3e	; 62
 114:	14 2f       	mov	r17, r20
	NRF24_SET_CSN_LOW;
 116:	db 98       	cbi	0x1b, 3	; 27
	SPI_WriteReadByte(cmd);
 118:	69 83       	std	Y+1, r22	; 0x01
 11a:	7a 83       	std	Y+2, r23	; 0x02
 11c:	ea df       	rcall	.-44     	; 0xf2 <SPI_WriteReadByte>
	while(len-- > 0) *array++ = SPI_WriteReadByte(NRF24_CMD_NOP);
 11e:	69 81       	ldd	r22, Y+1	; 0x01
 120:	e6 2e       	mov	r14, r22
 122:	7a 81       	ldd	r23, Y+2	; 0x02
 124:	f7 2e       	mov	r15, r23
 126:	16 0f       	add	r17, r22
 128:	1e 15       	cp	r17, r14
 12a:	31 f0       	breq	.+12     	; 0x138 <NRF24_ReadArray+0x34>
 12c:	8f ef       	ldi	r24, 0xFF	; 255
 12e:	e1 df       	rcall	.-62     	; 0xf2 <SPI_WriteReadByte>
 130:	f7 01       	movw	r30, r14
 132:	81 93       	st	Z+, r24
 134:	7f 01       	movw	r14, r30
 136:	f8 cf       	rjmp	.-16     	; 0x128 <NRF24_ReadArray+0x24>
	NRF24_SET_CSN_HI;
 138:	db 9a       	sbi	0x1b, 3	; 27
}
 13a:	0f 90       	pop	r0
 13c:	0f 90       	pop	r0
 13e:	df 91       	pop	r29
 140:	cf 91       	pop	r28
 142:	1f 91       	pop	r17
 144:	ff 90       	pop	r15
 146:	ef 90       	pop	r14
 148:	08 95       	ret

0000014a <NRF24_WriteByte>:

void NRF24_WriteByte(uint8_t cmd, uint8_t value)
{
 14a:	cf 93       	push	r28
 14c:	df 93       	push	r29
 14e:	1f 92       	push	r1
 150:	cd b7       	in	r28, 0x3d	; 61
 152:	de b7       	in	r29, 0x3e	; 62
	NRF24_SET_CSN_LOW;
 154:	db 98       	cbi	0x1b, 3	; 27
	SPI_WriteReadByte(cmd);
 156:	69 83       	std	Y+1, r22	; 0x01
 158:	cc df       	rcall	.-104    	; 0xf2 <SPI_WriteReadByte>
	SPI_WriteReadByte(value);
 15a:	69 81       	ldd	r22, Y+1	; 0x01
 15c:	86 2f       	mov	r24, r22
 15e:	c9 df       	rcall	.-110    	; 0xf2 <SPI_WriteReadByte>
	NRF24_SET_CSN_HI;
 160:	db 9a       	sbi	0x1b, 3	; 27
}
 162:	0f 90       	pop	r0
 164:	df 91       	pop	r29
 166:	cf 91       	pop	r28
 168:	08 95       	ret

0000016a <NRF24_WriteArray>:

void NRF24_WriteArray(int8_t cmd, uint8_t *array, uint8_t len)
{
 16a:	ef 92       	push	r14
 16c:	ff 92       	push	r15
 16e:	1f 93       	push	r17
 170:	cf 93       	push	r28
 172:	df 93       	push	r29
 174:	00 d0       	rcall	.+0      	; 0x176 <NRF24_WriteArray+0xc>
 176:	cd b7       	in	r28, 0x3d	; 61
 178:	de b7       	in	r29, 0x3e	; 62
 17a:	14 2f       	mov	r17, r20
	NRF24_SET_CSN_LOW;
 17c:	db 98       	cbi	0x1b, 3	; 27
	SPI_WriteReadByte(cmd);
 17e:	69 83       	std	Y+1, r22	; 0x01
 180:	7a 83       	std	Y+2, r23	; 0x02
 182:	b7 df       	rcall	.-146    	; 0xf2 <SPI_WriteReadByte>
	while(len-- > 0) SPI_WriteReadByte(*array++);
 184:	69 81       	ldd	r22, Y+1	; 0x01
 186:	e6 2e       	mov	r14, r22
 188:	7a 81       	ldd	r23, Y+2	; 0x02
 18a:	f7 2e       	mov	r15, r23
 18c:	16 0f       	add	r17, r22
 18e:	1e 15       	cp	r17, r14
 190:	29 f0       	breq	.+10     	; 0x19c <NRF24_WriteArray+0x32>
 192:	f7 01       	movw	r30, r14
 194:	81 91       	ld	r24, Z+
 196:	7f 01       	movw	r14, r30
 198:	ac df       	rcall	.-168    	; 0xf2 <SPI_WriteReadByte>
 19a:	f9 cf       	rjmp	.-14     	; 0x18e <NRF24_WriteArray+0x24>
	NRF24_SET_CSN_HI;
 19c:	db 9a       	sbi	0x1b, 3	; 27
}
 19e:	0f 90       	pop	r0
 1a0:	0f 90       	pop	r0
 1a2:	df 91       	pop	r29
 1a4:	cf 91       	pop	r28
 1a6:	1f 91       	pop	r17
 1a8:	ff 90       	pop	r15
 1aa:	ef 90       	pop	r14
 1ac:	08 95       	ret

000001ae <NRF24_SendCommand>:

uint8_t NRF24_SendCommand(uint8_t cmd) // Send command & receive status
{
	NRF24_SET_CSN_LOW;
 1ae:	db 98       	cbi	0x1b, 3	; 27
	uint8_t result = SPI_WriteReadByte(cmd);
 1b0:	a0 df       	rcall	.-192    	; 0xf2 <SPI_WriteReadByte>
	NRF24_SET_CSN_HI;
 1b2:	db 9a       	sbi	0x1b, 3	; 27
	return result;
}
 1b4:	08 95       	ret

000001b6 <NRF24_SetMode>:

void NRF24_SetMode(uint8_t mode) // Set mode in CONFIG reg
{
 1b6:	cf 93       	push	r28
 1b8:	c8 2f       	mov	r28, r24
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_CONFIG, NRF24_CONFIG | (1<<NRF24_BIT_PWR_UP) | mode);
 1ba:	68 2f       	mov	r22, r24
 1bc:	6e 67       	ori	r22, 0x7E	; 126
 1be:	80 e2       	ldi	r24, 0x20	; 32
 1c0:	c4 df       	rcall	.-120    	; 0x14a <NRF24_WriteByte>
	if(mode & NRF24_ReceiveMode) { // Receive mode
 1c2:	c0 ff       	sbrs	r28, 0
 1c4:	04 c0       	rjmp	.+8      	; 0x1ce <NRF24_SetMode+0x18>
		//NRF24_SendCommand(NRF24_CMD_FLUSH_RX);
		NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_STATUS, (1<<NRF24_BIT_RX_DR) | (1<<NRF24_BIT_TX_DS) | (1<<NRF24_BIT_MAX_RT)); // clear status
 1c6:	60 e7       	ldi	r22, 0x70	; 112
 1c8:	87 e2       	ldi	r24, 0x27	; 39
 1ca:	bf df       	rcall	.-130    	; 0x14a <NRF24_WriteByte>
		NRF24_SET_CE_HI; // start receiving
 1cc:	da 9a       	sbi	0x1b, 2	; 27
	}
}
 1ce:	cf 91       	pop	r28
 1d0:	08 95       	ret

000001d2 <NRF24_Transmit>:
	}
	return pipe;
}

uint8_t NRF24_Transmit(uint8_t *payload) // Transmit payload, return 0 if success, 1 - max retransmit count reached, 2 - module not response.
{
 1d2:	cf 93       	push	r28
 1d4:	df 93       	push	r29
 1d6:	ec 01       	movw	r28, r24
	NRF24_SET_CE_LOW;
 1d8:	da 98       	cbi	0x1b, 2	; 27
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_STATUS, (1<<NRF24_BIT_RX_DR) | (1<<NRF24_BIT_TX_DS) | (1<<NRF24_BIT_MAX_RT)); // clear status
 1da:	60 e7       	ldi	r22, 0x70	; 112
 1dc:	87 e2       	ldi	r24, 0x27	; 39
 1de:	b5 df       	rcall	.-150    	; 0x14a <NRF24_WriteByte>
	NRF24_SendCommand(NRF24_CMD_FLUSH_TX);
 1e0:	81 ee       	ldi	r24, 0xE1	; 225
 1e2:	e5 df       	rcall	.-54     	; 0x1ae <NRF24_SendCommand>
	NRF24_WriteArray(NRF24_CMD_W_TX_PAYLOAD, payload, NRF24_PAYLOAD_LEN);
 1e4:	44 e0       	ldi	r20, 0x04	; 4
 1e6:	be 01       	movw	r22, r28
 1e8:	80 ea       	ldi	r24, 0xA0	; 160
 1ea:	bf df       	rcall	.-130    	; 0x16a <NRF24_WriteArray>
	NRF24_SET_CE_HI; // Start transmission
 1ec:	da 9a       	sbi	0x1b, 2	; 27
 1ee:	cf ef       	ldi	r28, 0xFF	; 255
	uint8_t st = 0, i;
	for(i = 1; i != 0; i++)
	{
		Delay10us(20);
 1f0:	84 e1       	ldi	r24, 0x14	; 20
 1f2:	3a df       	rcall	.-396    	; 0x68 <Delay10us>
		st = NRF24_SendCommand(NRF24_CMD_NOP);
 1f4:	8f ef       	ldi	r24, 0xFF	; 255
 1f6:	db df       	rcall	.-74     	; 0x1ae <NRF24_SendCommand>
		if((st & ((1<<NRF24_BIT_MAX_RT) | (1<<NRF24_BIT_TX_DS)))) break; // stop if sent or max retransmit reached
 1f8:	98 2f       	mov	r25, r24
 1fa:	90 73       	andi	r25, 0x30	; 48
 1fc:	21 f4       	brne	.+8      	; 0x206 <NRF24_Transmit+0x34>
 1fe:	c1 50       	subi	r28, 0x01	; 1
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_STATUS, (1<<NRF24_BIT_RX_DR) | (1<<NRF24_BIT_TX_DS) | (1<<NRF24_BIT_MAX_RT)); // clear status
	NRF24_SendCommand(NRF24_CMD_FLUSH_TX);
	NRF24_WriteArray(NRF24_CMD_W_TX_PAYLOAD, payload, NRF24_PAYLOAD_LEN);
	NRF24_SET_CE_HI; // Start transmission
	uint8_t st = 0, i;
	for(i = 1; i != 0; i++)
 200:	b9 f7       	brne	.-18     	; 0x1f0 <NRF24_Transmit+0x1e>
	{
		Delay10us(20);
		st = NRF24_SendCommand(NRF24_CMD_NOP);
		if((st & ((1<<NRF24_BIT_MAX_RT) | (1<<NRF24_BIT_TX_DS)))) break; // stop if sent or max retransmit reached
	}
	return i == 0 ? 2 : !(st & (1<<NRF24_BIT_TX_DS));
 202:	82 e0       	ldi	r24, 0x02	; 2
 204:	05 c0       	rjmp	.+10     	; 0x210 <NRF24_Transmit+0x3e>
 206:	85 fb       	bst	r24, 5
 208:	88 27       	eor	r24, r24
 20a:	80 f9       	bld	r24, 0
 20c:	91 e0       	ldi	r25, 0x01	; 1
 20e:	89 27       	eor	r24, r25
}
 210:	df 91       	pop	r29
 212:	cf 91       	pop	r28
 214:	08 95       	ret

00000216 <NRF24_SetAddresses>:

uint8_t NRF24_SetAddresses(uint8_t addr_LSB) // Set addresses: NRF24_BASE_ADDR + addr_LSB, return 1 if success
{
 216:	cf 93       	push	r28
 218:	c8 2f       	mov	r28, r24
	NRF24_Buffer[0] = addr_LSB;
 21a:	80 93 89 00 	sts	0x0089, r24
	memcpy_P(NRF24_Buffer + 1, NRF24_BASE_ADDR, sizeof(NRF24_BASE_ADDR)/sizeof(NRF24_BASE_ADDR[0]));
 21e:	42 e0       	ldi	r20, 0x02	; 2
 220:	50 e0       	ldi	r21, 0x00	; 0
 222:	62 e2       	ldi	r22, 0x22	; 34
 224:	70 e0       	ldi	r23, 0x00	; 0
 226:	8a e8       	ldi	r24, 0x8A	; 138
 228:	90 e0       	ldi	r25, 0x00	; 0
 22a:	db d5       	rcall	.+2998   	; 0xde2 <memcpy_P>
	NRF24_WriteArray(NRF24_CMD_W_REGISTER | NRF24_REG_RX_ADDR_P0, NRF24_Buffer, NRF24_ADDRESS_LEN);
 22c:	43 e0       	ldi	r20, 0x03	; 3
 22e:	69 e8       	ldi	r22, 0x89	; 137
 230:	70 e0       	ldi	r23, 0x00	; 0
 232:	8a e2       	ldi	r24, 0x2A	; 42
 234:	9a df       	rcall	.-204    	; 0x16a <NRF24_WriteArray>
	NRF24_WriteArray(NRF24_CMD_W_REGISTER | NRF24_REG_TX_ADDR, NRF24_Buffer, NRF24_ADDRESS_LEN);
 236:	43 e0       	ldi	r20, 0x03	; 3
 238:	69 e8       	ldi	r22, 0x89	; 137
 23a:	70 e0       	ldi	r23, 0x00	; 0
 23c:	80 e3       	ldi	r24, 0x30	; 48
 23e:	95 df       	rcall	.-214    	; 0x16a <NRF24_WriteArray>
	NRF24_ReadArray(NRF24_CMD_R_REGISTER | NRF24_REG_TX_ADDR, NRF24_Buffer, NRF24_ADDRESS_LEN);
 240:	43 e0       	ldi	r20, 0x03	; 3
 242:	69 e8       	ldi	r22, 0x89	; 137
 244:	70 e0       	ldi	r23, 0x00	; 0
 246:	80 e1       	ldi	r24, 0x10	; 16
 248:	5d df       	rcall	.-326    	; 0x104 <NRF24_ReadArray>
	return NRF24_Buffer[0] == addr_LSB;
 24a:	81 e0       	ldi	r24, 0x01	; 1
 24c:	90 91 89 00 	lds	r25, 0x0089
 250:	9c 13       	cpse	r25, r28
 252:	80 e0       	ldi	r24, 0x00	; 0
}
 254:	cf 91       	pop	r28
 256:	08 95       	ret

00000258 <NRF24_init>:
	NRF24_SET_CE_LOW;
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_CONFIG, NRF24_CONFIG); // Power down
}

void NRF24_init(uint8_t channel) // After init transmit must be delayed
{
 258:	1f 93       	push	r17
 25a:	cf 93       	push	r28
 25c:	df 93       	push	r29
 25e:	18 2f       	mov	r17, r24
	NRF24_SET_CSN_HI;
 260:	db 9a       	sbi	0x1b, 3	; 27
 262:	c4 e2       	ldi	r28, 0x24	; 36
 264:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i = 0, c, v;
	do {
		c = pgm_read_byte(&NRF24_INIT_DATA[i++]);
 266:	fe 01       	movw	r30, r28
 268:	84 91       	lpm	r24, Z
 26a:	31 96       	adiw	r30, 0x01	; 1
		v = pgm_read_byte(&NRF24_INIT_DATA[i++]);
 26c:	64 91       	lpm	r22, Z
		NRF24_WriteByte(c, v); 
 26e:	6d df       	rcall	.-294    	; 0x14a <NRF24_WriteByte>
 270:	22 96       	adiw	r28, 0x02	; 2
	} while(i < sizeof(NRF24_INIT_DATA));
 272:	f0 e0       	ldi	r31, 0x00	; 0
 274:	c0 33       	cpi	r28, 0x30	; 48
 276:	df 07       	cpc	r29, r31
 278:	b1 f7       	brne	.-20     	; 0x266 <NRF24_init+0xe>
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH,	channel);
 27a:	61 2f       	mov	r22, r17
 27c:	85 e2       	ldi	r24, 0x25	; 37
}
 27e:	df 91       	pop	r29
 280:	cf 91       	pop	r28
 282:	1f 91       	pop	r17
	do {
		c = pgm_read_byte(&NRF24_INIT_DATA[i++]);
		v = pgm_read_byte(&NRF24_INIT_DATA[i++]);
		NRF24_WriteByte(c, v); 
	} while(i < sizeof(NRF24_INIT_DATA));
	NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH,	channel);
 284:	62 cf       	rjmp	.-316    	; 0x14a <NRF24_WriteByte>

00000286 <__vector_4>:

#define SETUP_WATCHDOG WDTCSR = (1<<WDCE) | (1<<WDE); WDTCSR = (1<<WDE) | (1<<WDIE) | (0<<WDP3) | (0<<WDP2) | (1<<WDP1) | (1<<WDP0);	//  Watchdog 0.125 s
uint8_t LED_WarningOnCnt = 0, LED_WarningOffCnt = 0, LED_Warning_WorkLong = 0, LED_Warning_WorkShort = 0, LED_Warning_NoRepeat = 0;

ISR(WATCHDOG_vect)
{
 286:	1f 92       	push	r1
 288:	0f 92       	push	r0
 28a:	0f b6       	in	r0, 0x3f	; 63
 28c:	0f 92       	push	r0
 28e:	11 24       	eor	r1, r1
 290:	8f 93       	push	r24
 292:	9f 93       	push	r25
	SETUP_WATCHDOG;
 294:	88 e1       	ldi	r24, 0x18	; 24
 296:	81 bd       	out	0x21, r24	; 33
 298:	8b e4       	ldi	r24, 0x4B	; 75
 29a:	81 bd       	out	0x21, r24	; 33
	if(Timer) Timer--;
 29c:	80 91 61 00 	lds	r24, 0x0061
 2a0:	88 23       	and	r24, r24
 2a2:	29 f0       	breq	.+10     	; 0x2ae <__vector_4+0x28>
 2a4:	80 91 61 00 	lds	r24, 0x0061
 2a8:	81 50       	subi	r24, 0x01	; 1
 2aa:	80 93 61 00 	sts	0x0061, r24
	if(KeyOkTimeout) KeyOkTimeout--;
 2ae:	80 91 70 00 	lds	r24, 0x0070
 2b2:	88 23       	and	r24, r24
 2b4:	19 f0       	breq	.+6      	; 0x2bc <__vector_4+0x36>
 2b6:	81 50       	subi	r24, 0x01	; 1
 2b8:	80 93 70 00 	sts	0x0070, r24
	// LED_Warning: 0xF0 mask - Number of long flashes, 0x0F mask - Number of short flashes
	if(LED_WarningOnCnt) {
 2bc:	80 91 67 00 	lds	r24, 0x0067
 2c0:	88 23       	and	r24, r24
 2c2:	39 f0       	breq	.+14     	; 0x2d2 <__vector_4+0x4c>
		LED1_ON;
 2c4:	d9 9a       	sbi	0x1b, 1	; 27
		LED_WarningOnCnt--;
 2c6:	80 91 67 00 	lds	r24, 0x0067
 2ca:	81 50       	subi	r24, 0x01	; 1
 2cc:	80 93 67 00 	sts	0x0067, r24
 2d0:	44 c0       	rjmp	.+136    	; 0x35a <__vector_4+0xd4>
	} else if(LED_WarningOffCnt) {	
 2d2:	80 91 66 00 	lds	r24, 0x0066
 2d6:	88 23       	and	r24, r24
 2d8:	29 f0       	breq	.+10     	; 0x2e4 <__vector_4+0x5e>
		LED1_OFF;
 2da:	d9 98       	cbi	0x1b, 1	; 27
		LED_WarningOffCnt--;
 2dc:	80 91 66 00 	lds	r24, 0x0066
 2e0:	81 50       	subi	r24, 0x01	; 1
 2e2:	0f c0       	rjmp	.+30     	; 0x302 <__vector_4+0x7c>
	} else if(LED_Warning_WorkLong) { // long flashes
 2e4:	80 91 65 00 	lds	r24, 0x0065
 2e8:	88 23       	and	r24, r24
 2ea:	71 f0       	breq	.+28     	; 0x308 <__vector_4+0x82>
		LED_Warning_WorkLong--;
 2ec:	81 50       	subi	r24, 0x01	; 1
 2ee:	80 93 65 00 	sts	0x0065, r24
		LED_WarningOnCnt = 10;
 2f2:	9a e0       	ldi	r25, 0x0A	; 10
 2f4:	90 93 67 00 	sts	0x0067, r25
		if(LED_Warning_WorkLong == 0) {
 2f8:	81 11       	cpse	r24, r1
 2fa:	02 c0       	rjmp	.+4      	; 0x300 <__vector_4+0x7a>
			LED_WarningOffCnt = 6;
 2fc:	86 e0       	ldi	r24, 0x06	; 6
 2fe:	0e c0       	rjmp	.+28     	; 0x31c <__vector_4+0x96>
			goto xSetPause;
		} else LED_WarningOffCnt = 3;
 300:	83 e0       	ldi	r24, 0x03	; 3
 302:	80 93 66 00 	sts	0x0066, r24
 306:	29 c0       	rjmp	.+82     	; 0x35a <__vector_4+0xd4>
	} else if(LED_Warning_WorkShort) { // short flashes
 308:	80 91 64 00 	lds	r24, 0x0064
 30c:	88 23       	and	r24, r24
 30e:	71 f0       	breq	.+28     	; 0x32c <__vector_4+0xa6>
		LED_Warning_WorkShort--;
 310:	81 50       	subi	r24, 0x01	; 1
 312:	80 93 64 00 	sts	0x0064, r24
		LED_WarningOnCnt = 2;
 316:	82 e0       	ldi	r24, 0x02	; 2
 318:	80 93 67 00 	sts	0x0067, r24
		LED_WarningOffCnt = 2;
 31c:	80 93 66 00 	sts	0x0066, r24
xSetPause:	if(LED_Warning_WorkShort == 0) LED_WarningOffCnt = 20;
 320:	80 91 64 00 	lds	r24, 0x0064
 324:	81 11       	cpse	r24, r1
 326:	19 c0       	rjmp	.+50     	; 0x35a <__vector_4+0xd4>
 328:	84 e1       	ldi	r24, 0x14	; 20
 32a:	eb cf       	rjmp	.-42     	; 0x302 <__vector_4+0x7c>
	} else if(LED_Warning) {
 32c:	80 91 75 00 	lds	r24, 0x0075
 330:	88 23       	and	r24, r24
 332:	99 f0       	breq	.+38     	; 0x35a <__vector_4+0xd4>
		LED_Warning_WorkLong = (LED_Warning & 0xF0) >> 4;
 334:	80 91 75 00 	lds	r24, 0x0075
 338:	82 95       	swap	r24
 33a:	8f 70       	andi	r24, 0x0F	; 15
 33c:	80 93 65 00 	sts	0x0065, r24
		LED_Warning_WorkShort = LED_Warning & 0x0F;
 340:	80 91 75 00 	lds	r24, 0x0075
 344:	8f 70       	andi	r24, 0x0F	; 15
 346:	80 93 64 00 	sts	0x0064, r24
		if(LED_Warning_NoRepeat) {
 34a:	80 91 63 00 	lds	r24, 0x0063
 34e:	88 23       	and	r24, r24
 350:	21 f0       	breq	.+8      	; 0x35a <__vector_4+0xd4>
			LED_Warning_NoRepeat = 0;
 352:	10 92 63 00 	sts	0x0063, r1
			LED_Warning = 0;
 356:	10 92 75 00 	sts	0x0075, r1
		}
	}
}
 35a:	9f 91       	pop	r25
 35c:	8f 91       	pop	r24
 35e:	0f 90       	pop	r0
 360:	0f be       	out	0x3f, r0	; 63
 362:	0f 90       	pop	r0
 364:	1f 90       	pop	r1
 366:	18 95       	reti

00000368 <__vector_13>:

ISR(ADC_vect) // Light sensor
{
 368:	1f 92       	push	r1
 36a:	0f 92       	push	r0
 36c:	0f b6       	in	r0, 0x3f	; 63
 36e:	0f 92       	push	r0
 370:	11 24       	eor	r1, r1
 372:	2f 93       	push	r18
 374:	8f 93       	push	r24
 376:	9f 93       	push	r25
	LowLight = ADCH >= LowLightThreshold;
 378:	25 b1       	in	r18, 0x05	; 5
 37a:	81 e0       	ldi	r24, 0x01	; 1
 37c:	90 91 76 00 	lds	r25, 0x0076
 380:	29 17       	cp	r18, r25
 382:	08 f4       	brcc	.+2      	; 0x386 <__vector_13+0x1e>
 384:	80 e0       	ldi	r24, 0x00	; 0
 386:	80 93 74 00 	sts	0x0074, r24
}
 38a:	9f 91       	pop	r25
 38c:	8f 91       	pop	r24
 38e:	2f 91       	pop	r18
 390:	0f 90       	pop	r0
 392:	0f be       	out	0x3f, r0	; 63
 394:	0f 90       	pop	r0
 396:	1f 90       	pop	r1
 398:	18 95       	reti

0000039a <__vector_2>:

ISR(PCINT0_vect) // Sensor
{
 39a:	1f 92       	push	r1
 39c:	0f 92       	push	r0
 39e:	0f b6       	in	r0, 0x3f	; 63
 3a0:	0f 92       	push	r0
 3a2:	11 24       	eor	r1, r1
 3a4:	2f 93       	push	r18
 3a6:	3f 93       	push	r19
 3a8:	8f 93       	push	r24
 3aa:	9f 93       	push	r25
	if(CO2SensorState)
 3ac:	c8 9b       	sbis	0x19, 0	; 25
 3ae:	03 c0       	rjmp	.+6      	; 0x3b6 <__vector_2+0x1c>
	{ // Hi state
		TCNT1 = 0;
 3b0:	1d bc       	out	0x2d, r1	; 45
 3b2:	1c bc       	out	0x2c, r1	; 44
 3b4:	13 c0       	rjmp	.+38     	; 0x3dc <__vector_2+0x42>
	} else {
		CO2Level = (CO2Level + (TCNT1 / 4 - 4)) / 2; // tick = 0.125 ms, 350 ppm = 177ms, 2000 ppm = 1002ms
 3b6:	2c b5       	in	r18, 0x2c	; 44
 3b8:	3d b5       	in	r19, 0x2d	; 45
 3ba:	80 91 72 00 	lds	r24, 0x0072
 3be:	90 91 73 00 	lds	r25, 0x0073
 3c2:	04 97       	sbiw	r24, 0x04	; 4
 3c4:	36 95       	lsr	r19
 3c6:	27 95       	ror	r18
 3c8:	36 95       	lsr	r19
 3ca:	27 95       	ror	r18
 3cc:	82 0f       	add	r24, r18
 3ce:	93 1f       	adc	r25, r19
 3d0:	96 95       	lsr	r25
 3d2:	87 95       	ror	r24
 3d4:	90 93 73 00 	sts	0x0073, r25
 3d8:	80 93 72 00 	sts	0x0072, r24
	}
}
 3dc:	9f 91       	pop	r25
 3de:	8f 91       	pop	r24
 3e0:	3f 91       	pop	r19
 3e2:	2f 91       	pop	r18
 3e4:	0f 90       	pop	r0
 3e6:	0f be       	out	0x3f, r0	; 63
 3e8:	0f 90       	pop	r0
 3ea:	1f 90       	pop	r1
 3ec:	18 95       	reti

000003ee <__vector_8>:

ISR(TIM1_OVF_vect) // Sensor error show
{
 3ee:	1f 92       	push	r1
 3f0:	0f 92       	push	r0
 3f2:	0f b6       	in	r0, 0x3f	; 63
 3f4:	0f 92       	push	r0
 3f6:	11 24       	eor	r1, r1
 3f8:	8f 93       	push	r24
	if(LED_Warning == 0 && Setup == 0) {
 3fa:	80 91 75 00 	lds	r24, 0x0075
 3fe:	81 11       	cpse	r24, r1
 400:	0a c0       	rjmp	.+20     	; 0x416 <__vector_8+0x28>
 402:	80 91 6b 00 	lds	r24, 0x006B
 406:	81 11       	cpse	r24, r1
 408:	06 c0       	rjmp	.+12     	; 0x416 <__vector_8+0x28>
		LED_Warning = ERR_CO2Sensor;
 40a:	80 e4       	ldi	r24, 0x40	; 64
 40c:	80 93 75 00 	sts	0x0075, r24
		LED_Warning_NoRepeat = 1;
 410:	81 e0       	ldi	r24, 0x01	; 1
 412:	80 93 63 00 	sts	0x0063, r24
	}
}
 416:	8f 91       	pop	r24
 418:	0f 90       	pop	r0
 41a:	0f be       	out	0x3f, r0	; 63
 41c:	0f 90       	pop	r0
 41e:	1f 90       	pop	r1
 420:	18 95       	reti

00000422 <__vector_11>:

#define HASH_UPDATE IRHash = (IRHash << 4) + IRHash + IRReadedByte // hash=hash*17+b (better: hash=hash*33+b)
//#define HASH_UPDATE IRHash = _crc_ccitt_update(IRHash, IRReadedByte)
ISR(TIM0_OVF_vect) // IR
{
 422:	1f 92       	push	r1
 424:	0f 92       	push	r0
 426:	0f b6       	in	r0, 0x3f	; 63
 428:	0f 92       	push	r0
 42a:	11 24       	eor	r1, r1
 42c:	2f 93       	push	r18
 42e:	3f 93       	push	r19
 430:	4f 93       	push	r20
 432:	5f 93       	push	r21
 434:	8f 93       	push	r24
 436:	9f 93       	push	r25
	if(++IRSignalTimer == 0) { // overflow - command end
 438:	80 91 6f 00 	lds	r24, 0x006F
 43c:	8f 5f       	subi	r24, 0xFF	; 255
 43e:	80 93 6f 00 	sts	0x006F, r24
 442:	81 11       	cpse	r24, r1
 444:	34 c0       	rjmp	.+104    	; 0x4ae <__vector_11+0x8c>
		if(IRReceived != IRIsCommandReceived) {
 446:	80 91 6e 00 	lds	r24, 0x006E
 44a:	83 30       	cpi	r24, 0x03	; 3
 44c:	81 f1       	breq	.+96     	; 0x4ae <__vector_11+0x8c>
 44e:	40 91 6d 00 	lds	r20, 0x006D
			if(KEY1_PRESSING) { // key pressed
 452:	b2 99       	sbic	0x16, 2	; 22
 454:	08 c0       	rjmp	.+16     	; 0x466 <__vector_11+0x44>
				if(Key1Pressed != 255) Key1Pressed++;
 456:	4f 3f       	cpi	r20, 0xFF	; 255
 458:	19 f0       	breq	.+6      	; 0x460 <__vector_11+0x3e>
 45a:	4f 5f       	subi	r20, 0xFF	; 255
 45c:	40 93 6d 00 	sts	0x006D, r20
				IRReceived = 0;
 460:	10 92 6e 00 	sts	0x006E, r1
 464:	24 c0       	rjmp	.+72     	; 0x4ae <__vector_11+0x8c>
			} else {
				if(IRReceived == 2 && IRHead) {
 466:	82 30       	cpi	r24, 0x02	; 2
 468:	e1 f4       	brne	.+56     	; 0x4a2 <__vector_11+0x80>
 46a:	80 91 77 00 	lds	r24, 0x0077
 46e:	88 23       	and	r24, r24
 470:	c1 f0       	breq	.+48     	; 0x4a2 <__vector_11+0x80>
					IRReceived = IRIsCommandReceived; 
 472:	83 e0       	ldi	r24, 0x03	; 3
 474:	80 93 6e 00 	sts	0x006E, r24
					HASH_UPDATE;
 478:	20 91 79 00 	lds	r18, 0x0079
 47c:	30 91 7a 00 	lds	r19, 0x007A
 480:	c9 01       	movw	r24, r18
 482:	54 e0       	ldi	r21, 0x04	; 4
 484:	88 0f       	add	r24, r24
 486:	99 1f       	adc	r25, r25
 488:	5a 95       	dec	r21
 48a:	e1 f7       	brne	.-8      	; 0x484 <__vector_11+0x62>
 48c:	50 91 86 00 	lds	r21, 0x0086
 490:	85 0f       	add	r24, r21
 492:	91 1d       	adc	r25, r1
 494:	82 0f       	add	r24, r18
 496:	93 1f       	adc	r25, r19
 498:	90 93 7a 00 	sts	0x007A, r25
 49c:	80 93 79 00 	sts	0x0079, r24
 4a0:	02 c0       	rjmp	.+4      	; 0x4a6 <__vector_11+0x84>
				} else IRReceived = 0;
 4a2:	10 92 6e 00 	sts	0x006E, r1
				if(Key1Pressed < KEY1_PressingTimeMin) Key1Pressed = 0;
 4a6:	4a 30       	cpi	r20, 0x0A	; 10
 4a8:	10 f4       	brcc	.+4      	; 0x4ae <__vector_11+0x8c>
 4aa:	10 92 6d 00 	sts	0x006D, r1
			}
		}
	}
}
 4ae:	9f 91       	pop	r25
 4b0:	8f 91       	pop	r24
 4b2:	5f 91       	pop	r21
 4b4:	4f 91       	pop	r20
 4b6:	3f 91       	pop	r19
 4b8:	2f 91       	pop	r18
 4ba:	0f 90       	pop	r0
 4bc:	0f be       	out	0x3f, r0	; 63
 4be:	0f 90       	pop	r0
 4c0:	1f 90       	pop	r1
 4c2:	18 95       	reti

000004c4 <__vector_3>:

ISR(PCINT1_vect) // IR
{
 4c4:	1f 92       	push	r1
 4c6:	0f 92       	push	r0
 4c8:	0f b6       	in	r0, 0x3f	; 63
 4ca:	0f 92       	push	r0
 4cc:	11 24       	eor	r1, r1
 4ce:	2f 93       	push	r18
 4d0:	3f 93       	push	r19
 4d2:	4f 93       	push	r20
 4d4:	5f 93       	push	r21
 4d6:	8f 93       	push	r24
 4d8:	9f 93       	push	r25
	uint8_t bit;
	if(IRReceived == 0) {
 4da:	80 91 6e 00 	lds	r24, 0x006E
 4de:	81 11       	cpse	r24, r1
 4e0:	10 c0       	rjmp	.+32     	; 0x502 <__vector_3+0x3e>
		IRReceived = 1; // Start
 4e2:	81 e0       	ldi	r24, 0x01	; 1
 4e4:	80 93 6e 00 	sts	0x006E, r24
		IRSignalTimerLast = 0;
 4e8:	10 92 8d 00 	sts	0x008D, r1
		IRArrayBit = 0;
 4ec:	10 92 78 00 	sts	0x0078, r1
		IRReadedByte = 0;
 4f0:	10 92 86 00 	sts	0x0086, r1
		IRHash = 5381; // hash init
 4f4:	85 e0       	ldi	r24, 0x05	; 5
 4f6:	95 e1       	ldi	r25, 0x15	; 21
 4f8:	90 93 7a 00 	sts	0x007A, r25
 4fc:	80 93 79 00 	sts	0x0079, r24
		//IRHash = 0xFFFF; // crc init
		goto xEnd;
 500:	54 c0       	rjmp	.+168    	; 0x5aa <__vector_3+0xe6>
	} else if(IRReceived < IRIsCommandReceived) {
 502:	83 30       	cpi	r24, 0x03	; 3
 504:	08 f0       	brcs	.+2      	; 0x508 <__vector_3+0x44>
 506:	53 c0       	rjmp	.+166    	; 0x5ae <__vector_3+0xea>
 508:	40 91 6f 00 	lds	r20, 0x006F
		if(IRReceived == 1) { // Check first pulse width 
 50c:	81 30       	cpi	r24, 0x01	; 1
 50e:	a1 f4       	brne	.+40     	; 0x538 <__vector_3+0x74>
			uint8_t head = IRSignalTimer / 8;
 510:	84 2f       	mov	r24, r20
 512:	86 95       	lsr	r24
 514:	86 95       	lsr	r24
 516:	86 95       	lsr	r24
			if(head == IRHead) {
 518:	90 91 77 00 	lds	r25, 0x0077
 51c:	89 17       	cp	r24, r25
 51e:	31 f0       	breq	.+12     	; 0x52c <__vector_3+0x68>
				IRReceived = 2;
			} else if(SetupIR) {
 520:	90 91 6c 00 	lds	r25, 0x006C
 524:	99 23       	and	r25, r25
 526:	31 f0       	breq	.+12     	; 0x534 <__vector_3+0x70>
				IRHead = head;
 528:	80 93 77 00 	sts	0x0077, r24
				IRReceived = 2;
 52c:	82 e0       	ldi	r24, 0x02	; 2
 52e:	80 93 6e 00 	sts	0x006E, r24
 532:	02 c0       	rjmp	.+4      	; 0x538 <__vector_3+0x74>
			} else {
				IRReceived = 0;
 534:	10 92 6e 00 	sts	0x006E, r1
			}
		}
		if(IRSignalTimer > IRSignalTimerLast) // bit = a / b > 1.5
 538:	80 91 8d 00 	lds	r24, 0x008D
 53c:	84 17       	cp	r24, r20
 53e:	30 f4       	brcc	.+12     	; 0x54c <__vector_3+0x88>
			bit = (uint8_t)(IRSignalTimer - IRSignalTimerLast) > IRSignalTimerLast / 2;
 540:	24 2f       	mov	r18, r20
 542:	28 1b       	sub	r18, r24
 544:	98 2f       	mov	r25, r24
 546:	96 95       	lsr	r25
 548:	81 e0       	ldi	r24, 0x01	; 1
 54a:	05 c0       	rjmp	.+10     	; 0x556 <__vector_3+0x92>
		else
			bit = (uint8_t)(IRSignalTimerLast - IRSignalTimer) > IRSignalTimer / 2;
 54c:	28 2f       	mov	r18, r24
 54e:	24 1b       	sub	r18, r20
 550:	81 e0       	ldi	r24, 0x01	; 1
 552:	94 2f       	mov	r25, r20
 554:	96 95       	lsr	r25
 556:	92 17       	cp	r25, r18
 558:	08 f0       	brcs	.+2      	; 0x55c <__vector_3+0x98>
 55a:	80 e0       	ldi	r24, 0x00	; 0
		IRReadedByte = (IRReadedByte << 1) | bit;
 55c:	50 91 86 00 	lds	r21, 0x0086
 560:	55 0f       	add	r21, r21
 562:	58 2b       	or	r21, r24
 564:	50 93 86 00 	sts	0x0086, r21
		if(++IRArrayBit > 7) {
 568:	80 91 78 00 	lds	r24, 0x0078
 56c:	8f 5f       	subi	r24, 0xFF	; 255
 56e:	88 30       	cpi	r24, 0x08	; 8
 570:	18 f4       	brcc	.+6      	; 0x578 <__vector_3+0xb4>
 572:	80 93 78 00 	sts	0x0078, r24
 576:	17 c0       	rjmp	.+46     	; 0x5a6 <__vector_3+0xe2>
			IRArrayBit = 0;
 578:	10 92 78 00 	sts	0x0078, r1
			HASH_UPDATE;
 57c:	20 91 79 00 	lds	r18, 0x0079
 580:	30 91 7a 00 	lds	r19, 0x007A
 584:	c9 01       	movw	r24, r18
 586:	82 95       	swap	r24
 588:	92 95       	swap	r25
 58a:	90 7f       	andi	r25, 0xF0	; 240
 58c:	98 27       	eor	r25, r24
 58e:	80 7f       	andi	r24, 0xF0	; 240
 590:	98 27       	eor	r25, r24
 592:	82 0f       	add	r24, r18
 594:	93 1f       	adc	r25, r19
 596:	85 0f       	add	r24, r21
 598:	91 1d       	adc	r25, r1
 59a:	90 93 7a 00 	sts	0x007A, r25
 59e:	80 93 79 00 	sts	0x0079, r24
			IRReadedByte = 0;
 5a2:	10 92 86 00 	sts	0x0086, r1
		}
	IRSignalTimerLast = IRSignalTimer;
 5a6:	40 93 8d 00 	sts	0x008D, r20
xEnd:	IRSignalTimer = 0;
 5aa:	10 92 6f 00 	sts	0x006F, r1
	}
}
 5ae:	9f 91       	pop	r25
 5b0:	8f 91       	pop	r24
 5b2:	5f 91       	pop	r21
 5b4:	4f 91       	pop	r20
 5b6:	3f 91       	pop	r19
 5b8:	2f 91       	pop	r18
 5ba:	0f 90       	pop	r0
 5bc:	0f be       	out	0x3f, r0	; 63
 5be:	0f 90       	pop	r0
 5c0:	1f 90       	pop	r1
 5c2:	18 95       	reti

000005c4 <Set_LED_Warning>:

void Set_LED_Warning(uint8_t d)
{
	if(LED_Warning == 0 && Setup == 0) {
 5c4:	90 91 75 00 	lds	r25, 0x0075
 5c8:	91 11       	cpse	r25, r1
 5ca:	09 c0       	rjmp	.+18     	; 0x5de <Set_LED_Warning+0x1a>
 5cc:	90 91 6b 00 	lds	r25, 0x006B
 5d0:	91 11       	cpse	r25, r1
 5d2:	05 c0       	rjmp	.+10     	; 0x5de <Set_LED_Warning+0x1a>
		LED_Warning_NoRepeat = 1;
 5d4:	91 e0       	ldi	r25, 0x01	; 1
 5d6:	90 93 63 00 	sts	0x0063, r25
		LED_Warning = d;
 5da:	80 93 75 00 	sts	0x0075, r24
 5de:	08 95       	ret

000005e0 <ShowFanSpeedOverride>:
	}
}

void ShowFanSpeedOverride(int8_t speed)
{
	LED_WarningOnCnt = 0;
 5e0:	10 92 67 00 	sts	0x0067, r1
	LED_WarningOffCnt = 4;  // 0.5sec
 5e4:	94 e0       	ldi	r25, 0x04	; 4
 5e6:	90 93 66 00 	sts	0x0066, r25
	LED_Warning_NoRepeat = 1;
 5ea:	91 e0       	ldi	r25, 0x01	; 1
 5ec:	90 93 63 00 	sts	0x0063, r25
	if(speed >= 0)
 5f0:	87 fd       	sbrc	r24, 7
 5f2:	03 c0       	rjmp	.+6      	; 0x5fa <ShowFanSpeedOverride+0x1a>
		LED_Warning = speed;
 5f4:	80 93 75 00 	sts	0x0075, r24
 5f8:	08 95       	ret
	else {
		LED_Warning = -speed + 0x10;
 5fa:	90 e1       	ldi	r25, 0x10	; 16
 5fc:	98 1b       	sub	r25, r24
 5fe:	90 93 75 00 	sts	0x0075, r25
 602:	08 95       	ret

00000604 <rf_reset_chip>:
	}
}

void rf_reset_chip(void)
{
	RF_OFF1;
 604:	d7 98       	cbi	0x1a, 7	; 26
 606:	df 98       	cbi	0x1b, 7	; 27
	Delay100ms(20);
 608:	84 e1       	ldi	r24, 0x14	; 20
 60a:	90 e0       	ldi	r25, 0x00	; 0
 60c:	36 dd       	rcall	.-1428   	; 0x7a <Delay100ms>
	RF_OFF2;
 60e:	d7 9a       	sbi	0x1a, 7	; 26
	Delay100ms(10);
 610:	8a e0       	ldi	r24, 0x0A	; 10
 612:	90 e0       	ldi	r25, 0x00	; 0
 614:	32 dd       	rcall	.-1436   	; 0x7a <Delay100ms>
	RF_ON1;
 616:	d7 98       	cbi	0x1a, 7	; 26
 618:	df 9a       	sbi	0x1b, 7	; 27
	Delay100ms(2);
 61a:	82 e0       	ldi	r24, 0x02	; 2
 61c:	90 e0       	ldi	r25, 0x00	; 0
 61e:	2d dd       	rcall	.-1446   	; 0x7a <Delay100ms>
	RF_ON2;
 620:	d7 9a       	sbi	0x1a, 7	; 26
	Delay100ms(2);
 622:	82 e0       	ldi	r24, 0x02	; 2
 624:	90 e0       	ldi	r25, 0x00	; 0
 626:	29 dd       	rcall	.-1454   	; 0x7a <Delay100ms>
	NRF24_init(EEPROM_read(EPROM_RF_Channel));
 628:	87 e0       	ldi	r24, 0x07	; 7
 62a:	4f dd       	rcall	.-1378   	; 0xca <EEPROM_read>
 62c:	15 de       	rcall	.-982    	; 0x258 <NRF24_init>
	NRF24_SetMode(NRF24_TransmitMode);
 62e:	80 e0       	ldi	r24, 0x00	; 0
 630:	c2 dd       	rcall	.-1148   	; 0x1b6 <NRF24_SetMode>
	Delay100ms(1);
 632:	81 e0       	ldi	r24, 0x01	; 1
 634:	90 e0       	ldi	r25, 0x00	; 0
 636:	21 dd       	rcall	.-1470   	; 0x7a <Delay100ms>
	rf_last_addr = 0;
 638:	10 92 68 00 	sts	0x0068, r1
 63c:	08 95       	ret

0000063e <main>:
}

int main(void)
{
	CLKPR = (1<<CLKPCE); CLKPR = (0<<CLKPS3) | (0<<CLKPS2) | (0<<CLKPS1) | (0<<CLKPS0); // Clock prescaler division factor: 1
 63e:	80 e8       	ldi	r24, 0x80	; 128
 640:	86 bd       	out	0x26, r24	; 38
 642:	16 bc       	out	0x26, r1	; 38
	MCUCR = (1<<SE) | (0<<SM1) | (0<<SM0); // Idle sleep enable
 644:	80 e2       	ldi	r24, 0x20	; 32
 646:	85 bf       	out	0x35, r24	; 53
	DDRA = LED1; // Out
 648:	92 e0       	ldi	r25, 0x02	; 2
 64a:	9a bb       	out	0x1a, r25	; 26
	NRF24_DDR |= NRF24_CE | NRF24_CSN | NRF24_SCK | NRF24_MOSI; // Out
 64c:	8a b3       	in	r24, 0x1a	; 26
 64e:	8c 63       	ori	r24, 0x3C	; 60
 650:	8a bb       	out	0x1a, r24	; 26
	PORTB = (1<<PORTB0) | (1<<PORTB1); // Pullup not used
 652:	83 e0       	ldi	r24, 0x03	; 3
 654:	88 bb       	out	0x18, r24	; 24
	// Timer 8 bit		NRF24L01_Buffer	Unknown identifier	Error
	TCCR0A = (1<<WGM01) | (1<<WGM00);  // Timer0: Fast PWM OCRA
 656:	80 bf       	out	0x30, r24	; 48
	TCCR0B = (1<<WGM02) | (0 << CS02) | (1 << CS01) | (0 << CS00); // Timer0 prescaller: 8
 658:	8a e0       	ldi	r24, 0x0A	; 10
 65a:	83 bf       	out	0x33, r24	; 51
	OCR0A = 49; // OC0A - Fclk/(prescaller*(1+TOP)) = 20480hz
 65c:	81 e3       	ldi	r24, 0x31	; 49
 65e:	86 bf       	out	0x36, r24	; 54
	OCR0B = 0; // Half Duty cycle ((TOP+1)/2-1)
 660:	1c be       	out	0x3c, r1	; 60
	// Timer 16 bit
	TCCR1A = (1<<WGM11) | (0<<WGM10);  // Timer1: Fast PWM Top ICR1 (14)
 662:	9f bd       	out	0x2f, r25	; 47
	TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS12) | (0<<CS11) | (1<<CS10); // Timer1: /1024
 664:	8d e1       	ldi	r24, 0x1D	; 29
 666:	8e bd       	out	0x2e, r24	; 46
	ICR1 = 16000; // Max sensor value * 4. Sensor value must be less than 255 * 16 = 4080
 668:	80 e8       	ldi	r24, 0x80	; 128
 66a:	9e e3       	ldi	r25, 0x3E	; 62
 66c:	95 bd       	out	0x25, r25	; 37
 66e:	84 bd       	out	0x24, r24	; 36
	if(EEPROM_read(EPROM_ShowCO2SensorError)) {
 670:	85 e0       	ldi	r24, 0x05	; 5
 672:	2b dd       	rcall	.-1450   	; 0xca <EEPROM_read>
 674:	88 23       	and	r24, r24
 676:	11 f0       	breq	.+4      	; 0x67c <main+0x3e>
		TIMSK1 = (1<<TOIE1); // Timer/Counter1, Overflow Interrupt Enable
 678:	81 e0       	ldi	r24, 0x01	; 1
 67a:	8c b9       	out	0x0c, r24	; 12
 	ADMUX = (0<<REFS1) | (1<<MUX2)|(1<<MUX1)|(1<<MUX0); // ADC7 (PA7)
 	ADCSRA = (1<<ADEN) | (0<<ADATE) | (1<<ADIE) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); // ADC enable, Free Running mode, Interrupt, ADC 128 divider
 	ADCSRB = (1<<ADLAR) | (0<<ADTS2) | (0<<ADTS1) | (0<<ADTS0); // ADC Left Adjust Result
#endif
	// Pin change
 	GIMSK = (1<<PCIE0) | (1<<PCIE1); // Pin Change Interrupt Enable 0, 1
 67c:	80 e3       	ldi	r24, 0x30	; 48
 67e:	8b bf       	out	0x3b, r24	; 59
 	PCMSK0 = (1<<PCINT0); // Pin Change Mask Register 0 - Sensor
 680:	81 e0       	ldi	r24, 0x01	; 1
 682:	82 bb       	out	0x12, r24	; 18
 	PCMSK1 = (1<<PCINT8) | (1<<PCINT9) | (1<<PCINT10); // Pin Change Mask Register 0 - Keys
 684:	87 e0       	ldi	r24, 0x07	; 7
 686:	80 bd       	out	0x20, r24	; 32
	LowLightThreshold = EEPROM_read(EPROM_LowLightThreshold);
 688:	81 e0       	ldi	r24, 0x01	; 1
 68a:	1f dd       	rcall	.-1474   	; 0xca <EEPROM_read>
 68c:	80 93 76 00 	sts	0x0076, r24
	if(LowLightThreshold == 0xFF) {
 690:	8f 3f       	cpi	r24, 0xFF	; 255
 692:	49 f4       	brne	.+18     	; 0x6a6 <main+0x68>
		EEPROM_write(EPROM_OSCCAL, OSCCAL);
 694:	61 b7       	in	r22, 0x31	; 49
 696:	80 e0       	ldi	r24, 0x00	; 0
 698:	20 dd       	rcall	.-1472   	; 0xda <EEPROM_write>
		EEPROM_write(EPROM_NumberFans, 1);
 69a:	61 e0       	ldi	r22, 0x01	; 1
 69c:	82 e0       	ldi	r24, 0x02	; 2
 69e:	1d dd       	rcall	.-1478   	; 0xda <EEPROM_write>
		EEPROM_write(EPROM_LowLightThreshold, 0x90);
 6a0:	60 e9       	ldi	r22, 0x90	; 144
 6a2:	81 e0       	ldi	r24, 0x01	; 1
 6a4:	1a dd       	rcall	.-1484   	; 0xda <EEPROM_write>
	}
 	OSCCAL = EEPROM_read(EPROM_OSCCAL);
 6a6:	80 e0       	ldi	r24, 0x00	; 0
 6a8:	10 dd       	rcall	.-1504   	; 0xca <EEPROM_read>
 6aa:	81 bf       	out	0x31, r24	; 49
	// Prepare for IR receiving
	GIMSK |= (1<<PCIE1); // Pin Change Interrupt Enable 1
 6ac:	8b b7       	in	r24, 0x3b	; 59
 6ae:	80 62       	ori	r24, 0x20	; 32
 6b0:	8b bf       	out	0x3b, r24	; 59
	PCMSK1 |= (1<<PCINT10); // Pin Change Mask Register 0 - Keys
 6b2:	80 b5       	in	r24, 0x20	; 32
 6b4:	84 60       	ori	r24, 0x04	; 4
 6b6:	80 bd       	out	0x20, r24	; 32
	TIMSK0 |= (1<<TOIE0); // Timer/Counter0 Overflow Interrupt Enable
 6b8:	89 b7       	in	r24, 0x39	; 57
 6ba:	81 60       	ori	r24, 0x01	; 1
 6bc:	89 bf       	out	0x39, r24	; 57
	IRHead = EEPROM_read(EPROM_IRCommandHead);
 6be:	80 e3       	ldi	r24, 0x30	; 48
 6c0:	04 dd       	rcall	.-1528   	; 0xca <EEPROM_read>
 6c2:	80 93 77 00 	sts	0x0077, r24
	RF_ON1;
 6c6:	d7 98       	cbi	0x1a, 7	; 26
 6c8:	df 9a       	sbi	0x1b, 7	; 27
	FlashLED(3,3,3);
 6ca:	43 e0       	ldi	r20, 0x03	; 3
 6cc:	63 e0       	ldi	r22, 0x03	; 3
 6ce:	83 e0       	ldi	r24, 0x03	; 3
 6d0:	e2 dc       	rcall	.-1596   	; 0x96 <FlashLED>
	RF_ON2;
 6d2:	d7 9a       	sbi	0x1a, 7	; 26
	Delay100ms(1);
 6d4:	81 e0       	ldi	r24, 0x01	; 1
 6d6:	90 e0       	ldi	r25, 0x00	; 0
 6d8:	d0 dc       	rcall	.-1632   	; 0x7a <Delay100ms>
	SETUP_WATCHDOG;
 6da:	88 e1       	ldi	r24, 0x18	; 24
 6dc:	81 bd       	out	0x21, r24	; 33
 6de:	8b e4       	ldi	r24, 0x4B	; 75
 6e0:	81 bd       	out	0x21, r24	; 33
	sei();
 6e2:	78 94       	sei
	NRF24_init(EEPROM_read(EPROM_RF_Channel)); // After init transmit must be delayed
 6e4:	87 e0       	ldi	r24, 0x07	; 7
 6e6:	f1 dc       	rcall	.-1566   	; 0xca <EEPROM_read>
 6e8:	b7 dd       	rcall	.-1170   	; 0x258 <NRF24_init>
 6ea:	ee e8       	ldi	r30, 0x8E	; 142
 6ec:	f0 e0       	ldi	r31, 0x00	; 0
	for(uint8_t i = 0; i < MAX_FANS; i++) FanSpeedForce[i] = -1; // set auto
 6ee:	8f ef       	ldi	r24, 0xFF	; 255
 6f0:	81 93       	st	Z+, r24
 6f2:	90 e0       	ldi	r25, 0x00	; 0
 6f4:	e8 39       	cpi	r30, 0x98	; 152
 6f6:	f9 07       	cpc	r31, r25
 6f8:	d9 f7       	brne	.-10     	; 0x6f0 <main+0xb2>
	NRF24_SetMode(NRF24_TransmitMode);
 6fa:	80 e0       	ldi	r24, 0x00	; 0
 6fc:	5c dd       	rcall	.-1352   	; 0x1b6 <NRF24_SetMode>
	{
		__asm__ volatile ("" ::: "memory"); // Need memory barrier
		uint8_t i;
		sleep_cpu();
		IRKey = 0;
		if(IRReceived == IRIsCommandReceived) {
 6fe:	ff 24       	eor	r15, r15
 700:	f3 94       	inc	r15
				do {
					uint8_t j = EEPROM_read(i++);
					if(j == fan) {
						if((j = EEPROM_read(i++)) != 0xFF) { // Set RF channel
							NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH,	j);
							RF_Changed = 1;
 702:	01 e0       	ldi	r16, 0x01	; 1
xSetupIR:				SetupIR++;
						FlashLED(3, 1, 1);
						LED_Warning = SetupIR;
						Delay100ms(15);
						IRReceived = 0;
						Timer = 255;
 704:	1f ef       	ldi	r17, 0xFF	; 255
	NRF24_SetMode(NRF24_TransmitMode);
	while(1)
	{
		__asm__ volatile ("" ::: "memory"); // Need memory barrier
		uint8_t i;
		sleep_cpu();
 706:	88 95       	sleep
		IRKey = 0;
 708:	10 92 88 00 	sts	0x0088, r1
		if(IRReceived == IRIsCommandReceived) {
 70c:	80 91 6e 00 	lds	r24, 0x006E
 710:	83 30       	cpi	r24, 0x03	; 3
 712:	b9 f4       	brne	.+46     	; 0x742 <main+0x104>
 714:	d1 e3       	ldi	r29, 0x31	; 49
 716:	c1 e0       	ldi	r28, 0x01	; 1
			for(i = 0; i < IRCommands; i++) {
				if(EEPROM_read(EPROM_IRCommandArray + i * sizeof(IRHash)) == (uint8_t) (IRHash % 256)
 718:	8d 2f       	mov	r24, r29
 71a:	d7 dc       	rcall	.-1618   	; 0xca <EEPROM_read>
 71c:	90 91 79 00 	lds	r25, 0x0079
 720:	89 13       	cpse	r24, r25
 722:	09 c0       	rjmp	.+18     	; 0x736 <main+0xf8>
					&& EEPROM_read(EPROM_IRCommandArray + i * sizeof(IRHash) + 1) == (uint8_t) (IRHash / 256)) IRKey = i + 1;
 724:	81 e0       	ldi	r24, 0x01	; 1
 726:	8d 0f       	add	r24, r29
 728:	d0 dc       	rcall	.-1632   	; 0xca <EEPROM_read>
 72a:	90 91 7a 00 	lds	r25, 0x007A
 72e:	89 13       	cpse	r24, r25
 730:	02 c0       	rjmp	.+4      	; 0x736 <main+0xf8>
 732:	c0 93 88 00 	sts	0x0088, r28
 736:	cf 5f       	subi	r28, 0xFF	; 255
 738:	de 5f       	subi	r29, 0xFE	; 254
		__asm__ volatile ("" ::: "memory"); // Need memory barrier
		uint8_t i;
		sleep_cpu();
		IRKey = 0;
		if(IRReceived == IRIsCommandReceived) {
			for(i = 0; i < IRCommands; i++) {
 73a:	c5 30       	cpi	r28, 0x05	; 5
 73c:	69 f7       	brne	.-38     	; 0x718 <main+0xda>
				if(EEPROM_read(EPROM_IRCommandArray + i * sizeof(IRHash)) == (uint8_t) (IRHash % 256)
					&& EEPROM_read(EPROM_IRCommandArray + i * sizeof(IRHash) + 1) == (uint8_t) (IRHash / 256)) IRKey = i + 1;
			}
			IRReceived = 0;
 73e:	10 92 6e 00 	sts	0x006E, r1
		}
		switch(IRKey) {
 742:	c0 91 88 00 	lds	r28, 0x0088
 746:	c2 30       	cpi	r28, 0x02	; 2
 748:	09 f4       	brne	.+2      	; 0x74c <main+0x10e>
 74a:	58 c0       	rjmp	.+176    	; 0x7fc <main+0x1be>
 74c:	18 f4       	brcc	.+6      	; 0x754 <main+0x116>
 74e:	c1 30       	cpi	r28, 0x01	; 1
 750:	41 f0       	breq	.+16     	; 0x762 <main+0x124>
 752:	f7 c1       	rjmp	.+1006   	; 0xb42 <main+0x504>
 754:	c3 30       	cpi	r28, 0x03	; 3
 756:	09 f4       	brne	.+2      	; 0x75a <main+0x11c>
 758:	a5 c0       	rjmp	.+330    	; 0x8a4 <main+0x266>
 75a:	c4 30       	cpi	r28, 0x04	; 4
 75c:	09 f4       	brne	.+2      	; 0x760 <main+0x122>
 75e:	53 c1       	rjmp	.+678    	; 0xa06 <main+0x3c8>
 760:	f0 c1       	rjmp	.+992    	; 0xb42 <main+0x504>
			case IRKey_Up: {
				LED_Warning_WorkLong = 0;
 762:	10 92 65 00 	sts	0x0065, r1
				LED_Warning_WorkShort = 0;
 766:	10 92 64 00 	sts	0x0064, r1
				if(Setup == 0) {
 76a:	80 91 6b 00 	lds	r24, 0x006B
 76e:	81 11       	cpse	r24, r1
 770:	07 c0       	rjmp	.+14     	; 0x780 <main+0x142>
					if(FanSpeedOverride < FanSpeedMax) {
 772:	80 91 71 00 	lds	r24, 0x0071
 776:	86 30       	cpi	r24, 0x06	; 6
 778:	0c f0       	brlt	.+2      	; 0x77c <main+0x13e>
 77a:	e3 c1       	rjmp	.+966    	; 0xb42 <main+0x504>
						FanSpeedOverride++;
 77c:	8f 5f       	subi	r24, 0xFF	; 255
 77e:	48 c0       	rjmp	.+144    	; 0x810 <main+0x1d2>
						Timer = 0;
					}
				} else {
					LED_Warning_WorkLong = 0;
					LED_Warning_WorkShort = 0;
					Timer = 255;
 780:	10 93 61 00 	sts	0x0061, r17
 784:	90 91 7b 00 	lds	r25, 0x007B
					if(Setup == 1) {
 788:	81 30       	cpi	r24, 0x01	; 1
 78a:	31 f4       	brne	.+12     	; 0x798 <main+0x15a>
						if(++SetupItem > 5) SetupItem = 5; // Max menu item reached
 78c:	9f 5f       	subi	r25, 0xFF	; 255
 78e:	96 30       	cpi	r25, 0x06	; 6
 790:	08 f4       	brcc	.+2      	; 0x794 <main+0x156>
 792:	4e c0       	rjmp	.+156    	; 0x830 <main+0x1f2>
 794:	85 e0       	ldi	r24, 0x05	; 5
 796:	4f c0       	rjmp	.+158    	; 0x836 <main+0x1f8>
						LED_Warning = SetupItem;
					} else {
						if(SetupItem == 3) { // Modify EEPROM
 798:	93 30       	cpi	r25, 0x03	; 3
 79a:	71 f4       	brne	.+28     	; 0x7b8 <main+0x17a>
							if(Setup == 2) LED_Warning = ++datapos; else LED_Warning = ++data;
 79c:	82 30       	cpi	r24, 0x02	; 2
 79e:	21 f4       	brne	.+8      	; 0x7a8 <main+0x16a>
 7a0:	80 91 6a 00 	lds	r24, 0x006A
 7a4:	8f 5f       	subi	r24, 0xFF	; 255
 7a6:	53 c0       	rjmp	.+166    	; 0x84e <main+0x210>
 7a8:	80 91 69 00 	lds	r24, 0x0069
 7ac:	8f 5f       	subi	r24, 0xFF	; 255
 7ae:	80 93 69 00 	sts	0x0069, r24
 7b2:	80 93 75 00 	sts	0x0075, r24
 7b6:	c5 c1       	rjmp	.+906    	; 0xb42 <main+0x504>
						} else if(SetupItem == 4) { // fans override
 7b8:	94 30       	cpi	r25, 0x04	; 4
 7ba:	09 f0       	breq	.+2      	; 0x7be <main+0x180>
 7bc:	c2 c1       	rjmp	.+900    	; 0xb42 <main+0x504>
 7be:	c0 91 6a 00 	lds	r28, 0x006A
							if(Setup == 2) { // select fan
 7c2:	82 30       	cpi	r24, 0x02	; 2
 7c4:	51 f4       	brne	.+20     	; 0x7da <main+0x19c>
								if(datapos <= EEPROM_read(EPROM_NumberFans)) datapos++;
 7c6:	81 dc       	rcall	.-1790   	; 0xca <EEPROM_read>
 7c8:	8c 17       	cp	r24, r28
 7ca:	08 f4       	brcc	.+2      	; 0x7ce <main+0x190>
 7cc:	53 c0       	rjmp	.+166    	; 0x874 <main+0x236>
 7ce:	80 91 6a 00 	lds	r24, 0x006A
 7d2:	8f 5f       	subi	r24, 0xFF	; 255
 7d4:	80 93 6a 00 	sts	0x006A, r24
 7d8:	4d c0       	rjmp	.+154    	; 0x874 <main+0x236>
								LED_Warning = datapos;
							} else { // fan override
								if(SetupType) { // Forced speed
 7da:	80 91 87 00 	lds	r24, 0x0087
									if(FanSpeedForce[datapos - 1] < FanSpeedMax) {
 7de:	ec 2f       	mov	r30, r28
 7e0:	f0 e0       	ldi	r31, 0x00	; 0
						} else if(SetupItem == 4) { // fans override
							if(Setup == 2) { // select fan
								if(datapos <= EEPROM_read(EPROM_NumberFans)) datapos++;
								LED_Warning = datapos;
							} else { // fan override
								if(SetupType) { // Forced speed
 7e2:	88 23       	and	r24, r24
 7e4:	19 f0       	breq	.+6      	; 0x7ec <main+0x1ae>
									if(FanSpeedForce[datapos - 1] < FanSpeedMax) {
 7e6:	e3 57       	subi	r30, 0x73	; 115
 7e8:	ff 4f       	sbci	r31, 0xFF	; 255
 7ea:	02 c0       	rjmp	.+4      	; 0x7f0 <main+0x1b2>
										ShowFanSpeedOverride(++FanSpeedForce[datapos - 1]);
									}
								} else if(FanSpeedOverrideArray[datapos - 1] < FanSpeedMax) { // set delta
 7ec:	e5 58       	subi	r30, 0x85	; 133
 7ee:	ff 4f       	sbci	r31, 0xFF	; 255
 7f0:	80 81       	ld	r24, Z
 7f2:	86 30       	cpi	r24, 0x06	; 6
 7f4:	0c f0       	brlt	.+2      	; 0x7f8 <main+0x1ba>
 7f6:	fb c1       	rjmp	.+1014   	; 0xbee <main+0x5b0>
									ShowFanSpeedOverride(++FanSpeedOverrideArray[datapos - 1]);
 7f8:	8f 5f       	subi	r24, 0xFF	; 255
 7fa:	51 c0       	rjmp	.+162    	; 0x89e <main+0x260>
						}
					}
				}
				break;
			} case IRKey_Down: {
				if(Setup == 0) {
 7fc:	80 91 6b 00 	lds	r24, 0x006B
 800:	81 11       	cpse	r24, r1
 802:	0a c0       	rjmp	.+20     	; 0x818 <main+0x1da>
					if(FanSpeedOverride > -FanSpeedMax) {
 804:	80 91 71 00 	lds	r24, 0x0071
 808:	8b 3f       	cpi	r24, 0xFB	; 251
 80a:	0c f4       	brge	.+2      	; 0x80e <main+0x1d0>
 80c:	9a c1       	rjmp	.+820    	; 0xb42 <main+0x504>
						FanSpeedOverride--;
 80e:	81 50       	subi	r24, 0x01	; 1
 810:	80 93 71 00 	sts	0x0071, r24
						ShowFanSpeedOverride(FanSpeedOverride);
 814:	e5 de       	rcall	.-566    	; 0x5e0 <ShowFanSpeedOverride>
 816:	93 c1       	rjmp	.+806    	; 0xb3e <main+0x500>
						Timer = 0;
					}
				} else {
					LED_Warning_WorkLong = 0;
 818:	10 92 65 00 	sts	0x0065, r1
					LED_Warning_WorkShort = 0;
 81c:	10 92 64 00 	sts	0x0064, r1
					Timer = 255;
 820:	10 93 61 00 	sts	0x0061, r17
 824:	90 91 7b 00 	lds	r25, 0x007B
					if(Setup == 1) {
 828:	81 30       	cpi	r24, 0x01	; 1
 82a:	51 f4       	brne	.+20     	; 0x840 <main+0x202>
						if(--SetupItem == 0) SetupItem = 1; // Min menu item reached
 82c:	91 50       	subi	r25, 0x01	; 1
 82e:	19 f0       	breq	.+6      	; 0x836 <main+0x1f8>
 830:	90 93 7b 00 	sts	0x007B, r25
 834:	02 c0       	rjmp	.+4      	; 0x83a <main+0x1fc>
 836:	80 93 7b 00 	sts	0x007B, r24
						LED_Warning = SetupItem;
 83a:	80 91 7b 00 	lds	r24, 0x007B
 83e:	b9 cf       	rjmp	.-142    	; 0x7b2 <main+0x174>
					} else {
						if(SetupItem == 3) { // Modify EEPROM
 840:	93 30       	cpi	r25, 0x03	; 3
 842:	61 f4       	brne	.+24     	; 0x85c <main+0x21e>
							if(Setup == 2) LED_Warning = --datapos; else LED_Warning = --data;
 844:	82 30       	cpi	r24, 0x02	; 2
 846:	31 f4       	brne	.+12     	; 0x854 <main+0x216>
 848:	80 91 6a 00 	lds	r24, 0x006A
 84c:	81 50       	subi	r24, 0x01	; 1
 84e:	80 93 6a 00 	sts	0x006A, r24
 852:	af cf       	rjmp	.-162    	; 0x7b2 <main+0x174>
 854:	80 91 69 00 	lds	r24, 0x0069
 858:	81 50       	subi	r24, 0x01	; 1
 85a:	a9 cf       	rjmp	.-174    	; 0x7ae <main+0x170>
						} else if(SetupItem == 4) { // fans override - select fan
 85c:	94 30       	cpi	r25, 0x04	; 4
 85e:	09 f0       	breq	.+2      	; 0x862 <main+0x224>
 860:	70 c1       	rjmp	.+736    	; 0xb42 <main+0x504>
 862:	e0 91 6a 00 	lds	r30, 0x006A
							if(Setup == 2) { // select fan
 866:	82 30       	cpi	r24, 0x02	; 2
 868:	41 f4       	brne	.+16     	; 0x87a <main+0x23c>
								if(datapos > 1) datapos--;
 86a:	e2 30       	cpi	r30, 0x02	; 2
 86c:	18 f0       	brcs	.+6      	; 0x874 <main+0x236>
 86e:	e1 50       	subi	r30, 0x01	; 1
 870:	e0 93 6a 00 	sts	0x006A, r30
								LED_Warning = datapos;
 874:	80 91 6a 00 	lds	r24, 0x006A
 878:	9c cf       	rjmp	.-200    	; 0x7b2 <main+0x174>
							} else { // fan override
								if(SetupType) { // Forced speed
 87a:	80 91 87 00 	lds	r24, 0x0087
									if(FanSpeedForce[datapos - 1] > -1) {
 87e:	f0 e0       	ldi	r31, 0x00	; 0
						} else if(SetupItem == 4) { // fans override - select fan
							if(Setup == 2) { // select fan
								if(datapos > 1) datapos--;
								LED_Warning = datapos;
							} else { // fan override
								if(SetupType) { // Forced speed
 880:	88 23       	and	r24, r24
 882:	31 f0       	breq	.+12     	; 0x890 <main+0x252>
									if(FanSpeedForce[datapos - 1] > -1) {
 884:	e3 57       	subi	r30, 0x73	; 115
 886:	ff 4f       	sbci	r31, 0xFF	; 255
 888:	80 81       	ld	r24, Z
 88a:	87 fd       	sbrc	r24, 7
 88c:	b0 c1       	rjmp	.+864    	; 0xbee <main+0x5b0>
 88e:	06 c0       	rjmp	.+12     	; 0x89c <main+0x25e>
										ShowFanSpeedOverride(--FanSpeedForce[datapos - 1]);
									}
								} else if(FanSpeedOverrideArray[datapos - 1] > -FanSpeedMax) { // set delta
 890:	e5 58       	subi	r30, 0x85	; 133
 892:	ff 4f       	sbci	r31, 0xFF	; 255
 894:	80 81       	ld	r24, Z
 896:	8b 3f       	cpi	r24, 0xFB	; 251
 898:	0c f4       	brge	.+2      	; 0x89c <main+0x25e>
 89a:	a9 c1       	rjmp	.+850    	; 0xbee <main+0x5b0>
									ShowFanSpeedOverride(--FanSpeedOverrideArray[datapos - 1]);
 89c:	81 50       	subi	r24, 0x01	; 1
 89e:	80 83       	st	Z, r24
 8a0:	9f de       	rcall	.-706    	; 0x5e0 <ShowFanSpeedOverride>
 8a2:	a5 c1       	rjmp	.+842    	; 0xbee <main+0x5b0>
						}
					}
				}
				break;
			} case IRKey_Ok: {
				if(Setup) {
 8a4:	80 91 6b 00 	lds	r24, 0x006B
 8a8:	88 23       	and	r24, r24
 8aa:	09 f4       	brne	.+2      	; 0x8ae <main+0x270>
 8ac:	99 c0       	rjmp	.+306    	; 0x9e0 <main+0x3a2>
					FlashLED(1,1,1);
 8ae:	41 e0       	ldi	r20, 0x01	; 1
 8b0:	61 e0       	ldi	r22, 0x01	; 1
 8b2:	81 e0       	ldi	r24, 0x01	; 1
 8b4:	f0 db       	rcall	.-2080   	; 0x96 <FlashLED>
					Timer = 255;
 8b6:	10 93 61 00 	sts	0x0061, r17
					switch(SetupItem) {
 8ba:	80 91 7b 00 	lds	r24, 0x007B
 8be:	83 30       	cpi	r24, 0x03	; 3
 8c0:	51 f1       	breq	.+84     	; 0x916 <main+0x2d8>
 8c2:	30 f4       	brcc	.+12     	; 0x8d0 <main+0x292>
 8c4:	81 30       	cpi	r24, 0x01	; 1
 8c6:	09 f4       	brne	.+2      	; 0x8ca <main+0x28c>
 8c8:	34 c1       	rjmp	.+616    	; 0xb32 <main+0x4f4>
 8ca:	82 30       	cpi	r24, 0x02	; 2
 8cc:	99 f0       	breq	.+38     	; 0x8f4 <main+0x2b6>
 8ce:	78 c0       	rjmp	.+240    	; 0x9c0 <main+0x382>
 8d0:	84 30       	cpi	r24, 0x04	; 4
 8d2:	09 f4       	brne	.+2      	; 0x8d6 <main+0x298>
 8d4:	46 c0       	rjmp	.+140    	; 0x962 <main+0x324>
 8d6:	85 30       	cpi	r24, 0x05	; 5
 8d8:	09 f0       	breq	.+2      	; 0x8dc <main+0x29e>
 8da:	72 c0       	rjmp	.+228    	; 0x9c0 <main+0x382>
						} else { // delta entered
							LED_Warning = datapos;
						}
						break;
					case 5: // Show CO2 Level
						LED_Warning_WorkLong = 0;
 8dc:	10 92 65 00 	sts	0x0065, r1
						LED_Warning_WorkShort = 8;
 8e0:	88 e0       	ldi	r24, 0x08	; 8
 8e2:	80 93 64 00 	sts	0x0064, r24
						LED_Warning = CO2Level / 256;
 8e6:	80 91 73 00 	lds	r24, 0x0073
 8ea:	80 93 75 00 	sts	0x0075, r24
						LED_Warning_NoRepeat = 1;
 8ee:	00 93 63 00 	sts	0x0063, r16
 8f2:	4c c0       	rjmp	.+152    	; 0x98c <main+0x34e>
					Timer = 255;
					switch(SetupItem) {
					case 1: // Exit setup
						goto xSetupExit;
					case 2: // Set Low light
						if(Setup == 1)
 8f4:	80 91 6b 00 	lds	r24, 0x006B
 8f8:	81 30       	cpi	r24, 0x01	; 1
 8fa:	19 f4       	brne	.+6      	; 0x902 <main+0x2c4>
							LED_Warning = 0;
 8fc:	10 92 75 00 	sts	0x0075, r1
							Delay100ms(50);
							sleep_cpu();
							EEPROM_write(EPROM_LowLightThreshold, LowLightThreshold = ADCH);
							goto xSetupExit;
						}
						break;
 900:	5f c0       	rjmp	.+190    	; 0x9c0 <main+0x382>
						goto xSetupExit;
					case 2: // Set Low light
						if(Setup == 1)
							LED_Warning = 0;
						else {
							Delay100ms(50);
 902:	82 e3       	ldi	r24, 0x32	; 50
 904:	90 e0       	ldi	r25, 0x00	; 0
 906:	b9 db       	rcall	.-2190   	; 0x7a <Delay100ms>
							sleep_cpu();
 908:	88 95       	sleep
							EEPROM_write(EPROM_LowLightThreshold, LowLightThreshold = ADCH);
 90a:	65 b1       	in	r22, 0x05	; 5
 90c:	60 93 76 00 	sts	0x0076, r22
 910:	81 e0       	ldi	r24, 0x01	; 1
 912:	e3 db       	rcall	.-2106   	; 0xda <EEPROM_write>
							goto xSetupExit;
 914:	0e c1       	rjmp	.+540    	; 0xb32 <main+0x4f4>
						}
						break;
					case 3: // Edit EEPROM
						LED_Warning = 0; LED_Warning_WorkLong = 0; LED_Warning_WorkShort = 0;
 916:	10 92 75 00 	sts	0x0075, r1
 91a:	10 92 65 00 	sts	0x0065, r1
 91e:	10 92 64 00 	sts	0x0064, r1
						if(Setup == 1) {
 922:	80 91 6b 00 	lds	r24, 0x006B
 926:	81 30       	cpi	r24, 0x01	; 1
 928:	c9 f0       	breq	.+50     	; 0x95c <main+0x31e>
							LED_Warning = datapos = 1;
						} else if(Setup == 2) {
 92a:	82 30       	cpi	r24, 0x02	; 2
 92c:	41 f4       	brne	.+16     	; 0x93e <main+0x300>
							LED_Warning = data = EEPROM_read(datapos);
 92e:	80 91 6a 00 	lds	r24, 0x006A
 932:	cb db       	rcall	.-2154   	; 0xca <EEPROM_read>
 934:	80 93 69 00 	sts	0x0069, r24
 938:	80 93 75 00 	sts	0x0075, r24
 93c:	41 c0       	rjmp	.+130    	; 0x9c0 <main+0x382>
						} else if(data != EEPROM_read(datapos)) {
 93e:	c0 91 69 00 	lds	r28, 0x0069
 942:	80 91 6a 00 	lds	r24, 0x006A
 946:	c1 db       	rcall	.-2174   	; 0xca <EEPROM_read>
 948:	c8 17       	cp	r28, r24
 94a:	d1 f1       	breq	.+116    	; 0x9c0 <main+0x382>
							EEPROM_write(datapos, data);
 94c:	60 91 69 00 	lds	r22, 0x0069
 950:	80 91 6a 00 	lds	r24, 0x006A
 954:	c2 db       	rcall	.-2172   	; 0xda <EEPROM_write>
							LED_Warning = ++datapos;
 956:	80 91 6a 00 	lds	r24, 0x006A
 95a:	8f 5f       	subi	r24, 0xFF	; 255
 95c:	80 93 6a 00 	sts	0x006A, r24
 960:	eb cf       	rjmp	.-42     	; 0x938 <main+0x2fa>
						}
						break;
					case 4: // Fans override: fan selected
						if(Setup == 2) { // fan selected
 962:	80 91 6b 00 	lds	r24, 0x006B
 966:	e0 91 6a 00 	lds	r30, 0x006A
 96a:	82 30       	cpi	r24, 0x02	; 2
 96c:	41 f4       	brne	.+16     	; 0x97e <main+0x340>
							LED_Warning = 0;
 96e:	10 92 75 00 	sts	0x0075, r1
							ShowFanSpeedOverride(FanSpeedOverrideArray[datapos - 1]);
 972:	f0 e0       	ldi	r31, 0x00	; 0
 974:	e5 58       	subi	r30, 0x85	; 133
 976:	ff 4f       	sbci	r31, 0xFF	; 255
 978:	80 81       	ld	r24, Z
 97a:	32 de       	rcall	.-924    	; 0x5e0 <ShowFanSpeedOverride>
 97c:	21 c0       	rjmp	.+66     	; 0x9c0 <main+0x382>
						} else { // delta entered
							LED_Warning = datapos;
 97e:	e0 93 75 00 	sts	0x0075, r30
 982:	1e c0       	rjmp	.+60     	; 0x9c0 <main+0x382>
						LED_Warning = CO2Level / 256;
						LED_Warning_NoRepeat = 1;
						do { 
							__asm__ volatile ("" ::: "memory"); // Need memory barrier
							sleep_cpu(); 
						} while(Timer && (LED_Warning || LED_WarningOffCnt || LED_Warning_WorkLong || LED_Warning_WorkShort));
 984:	80 91 75 00 	lds	r24, 0x0075
 988:	88 23       	and	r24, r24
 98a:	31 f0       	breq	.+12     	; 0x998 <main+0x35a>
						LED_Warning_WorkShort = 8;
						LED_Warning = CO2Level / 256;
						LED_Warning_NoRepeat = 1;
						do { 
							__asm__ volatile ("" ::: "memory"); // Need memory barrier
							sleep_cpu(); 
 98c:	88 95       	sleep
						} while(Timer && (LED_Warning || LED_WarningOffCnt || LED_Warning_WorkLong || LED_Warning_WorkShort));
 98e:	80 91 61 00 	lds	r24, 0x0061
 992:	81 11       	cpse	r24, r1
 994:	f7 cf       	rjmp	.-18     	; 0x984 <main+0x346>
 996:	0c c0       	rjmp	.+24     	; 0x9b0 <main+0x372>
 998:	80 91 66 00 	lds	r24, 0x0066
 99c:	81 11       	cpse	r24, r1
 99e:	f6 cf       	rjmp	.-20     	; 0x98c <main+0x34e>
 9a0:	80 91 65 00 	lds	r24, 0x0065
 9a4:	81 11       	cpse	r24, r1
 9a6:	f2 cf       	rjmp	.-28     	; 0x98c <main+0x34e>
 9a8:	80 91 64 00 	lds	r24, 0x0064
 9ac:	81 11       	cpse	r24, r1
 9ae:	ee cf       	rjmp	.-36     	; 0x98c <main+0x34e>
						LED_Warning = CO2Level % 256;
 9b0:	80 91 72 00 	lds	r24, 0x0072
 9b4:	80 93 75 00 	sts	0x0075, r24
						LED_Warning_NoRepeat = 1;
 9b8:	00 93 63 00 	sts	0x0063, r16
						Setup = 0;
 9bc:	10 92 6b 00 	sts	0x006B, r1
						break;
					}
					if(Setup < 3)
 9c0:	80 91 6b 00 	lds	r24, 0x006B
 9c4:	83 30       	cpi	r24, 0x03	; 3
 9c6:	20 f4       	brcc	.+8      	; 0x9d0 <main+0x392>
						Setup++;
 9c8:	8f 5f       	subi	r24, 0xFF	; 255
 9ca:	80 93 6b 00 	sts	0x006B, r24
 9ce:	b9 c0       	rjmp	.+370    	; 0xb42 <main+0x504>
					else {
						Setup--;
 9d0:	81 50       	subi	r24, 0x01	; 1
 9d2:	80 93 6b 00 	sts	0x006B, r24
						FlashLED(5, 1, 1);
 9d6:	41 e0       	ldi	r20, 0x01	; 1
 9d8:	61 e0       	ldi	r22, 0x01	; 1
 9da:	85 e0       	ldi	r24, 0x05	; 5
 9dc:	5c db       	rcall	.-2376   	; 0x96 <FlashLED>
 9de:	b1 c0       	rjmp	.+354    	; 0xb42 <main+0x504>
					}
				} else {
					if(KeyOkTimeout == 0)
 9e0:	80 91 70 00 	lds	r24, 0x0070
 9e4:	81 11       	cpse	r24, r1
 9e6:	04 c0       	rjmp	.+8      	; 0x9f0 <main+0x3b2>
						KeyOkTimeout = 5; // 0.6 sec wait for the next Ok pressing
 9e8:	85 e0       	ldi	r24, 0x05	; 5
 9ea:	80 93 70 00 	sts	0x0070, r24
 9ee:	a9 c0       	rjmp	.+338    	; 0xb42 <main+0x504>
					else { // Ok was pressed 2 times within 0.5 sec
						KeyOkTimeout = 0;
 9f0:	10 92 70 00 	sts	0x0070, r1
						FlashLED(10, 1, 1);
 9f4:	41 e0       	ldi	r20, 0x01	; 1
 9f6:	61 e0       	ldi	r22, 0x01	; 1
 9f8:	8a e0       	ldi	r24, 0x0A	; 10
 9fa:	4d db       	rcall	.-2406   	; 0x96 <FlashLED>
						Setup = 1;
 9fc:	00 93 6b 00 	sts	0x006B, r16
						LED_Warning = SetupItem = 1; // setup item
 a00:	00 93 7b 00 	sts	0x007B, r16
 a04:	11 c0       	rjmp	.+34     	; 0xa28 <main+0x3ea>
						Timer = 255; // ~32 sec
					}
				}
				break;
			} case IRKey_FanOverride: {
				if(Setup == 0) {
 a06:	90 91 6b 00 	lds	r25, 0x006B
 a0a:	91 11       	cpse	r25, r1
 a0c:	10 c0       	rjmp	.+32     	; 0xa2e <main+0x3f0>
					FlashLED(3, 1, 1);
 a0e:	41 e0       	ldi	r20, 0x01	; 1
 a10:	61 e0       	ldi	r22, 0x01	; 1
 a12:	83 e0       	ldi	r24, 0x03	; 3
 a14:	40 db       	rcall	.-2432   	; 0x96 <FlashLED>
					Setup = 2;
 a16:	82 e0       	ldi	r24, 0x02	; 2
 a18:	80 93 6b 00 	sts	0x006B, r24
					SetupItem = 4;
 a1c:	c0 93 7b 00 	sts	0x007B, r28
					SetupType = 0;
 a20:	10 92 87 00 	sts	0x0087, r1
					LED_Warning = datapos = 1;
 a24:	00 93 6a 00 	sts	0x006A, r16
 a28:	00 93 75 00 	sts	0x0075, r16
 a2c:	31 c0       	rjmp	.+98     	; 0xa90 <main+0x452>
					Timer = 255; // ~32 sec
				} else if(SetupItem == 3) { // EEPROM edit
 a2e:	80 91 7b 00 	lds	r24, 0x007B
 a32:	83 30       	cpi	r24, 0x03	; 3
 a34:	51 f4       	brne	.+20     	; 0xa4a <main+0x40c>
					if(Setup == 2) LED_Warning = (datapos += 0x10); else LED_Warning = (data += 10); // add 0x10 to pos, 10 to byte
 a36:	92 30       	cpi	r25, 0x02	; 2
 a38:	21 f4       	brne	.+8      	; 0xa42 <main+0x404>
 a3a:	80 91 6a 00 	lds	r24, 0x006A
 a3e:	80 5f       	subi	r24, 0xF0	; 240
 a40:	06 cf       	rjmp	.-500    	; 0x84e <main+0x210>
 a42:	80 91 69 00 	lds	r24, 0x0069
 a46:	86 5f       	subi	r24, 0xF6	; 246
 a48:	b2 ce       	rjmp	.-668    	; 0x7ae <main+0x170>
				} else if(SetupItem == 4) { // Override menu item
 a4a:	84 30       	cpi	r24, 0x04	; 4
 a4c:	09 f0       	breq	.+2      	; 0xa50 <main+0x412>
 a4e:	71 c0       	rjmp	.+226    	; 0xb32 <main+0x4f4>
					SetupType ^= 1; // switch mode Fan Override / Fan Force
 a50:	80 91 87 00 	lds	r24, 0x0087
 a54:	8f 25       	eor	r24, r15
 a56:	80 93 87 00 	sts	0x0087, r24
					FlashLED(SetupType ? 6 : 3, 1, 1);
 a5a:	88 23       	and	r24, r24
 a5c:	11 f0       	breq	.+4      	; 0xa62 <main+0x424>
 a5e:	86 e0       	ldi	r24, 0x06	; 6
 a60:	01 c0       	rjmp	.+2      	; 0xa64 <main+0x426>
 a62:	83 e0       	ldi	r24, 0x03	; 3
 a64:	41 e0       	ldi	r20, 0x01	; 1
 a66:	61 e0       	ldi	r22, 0x01	; 1
 a68:	16 db       	rcall	.-2516   	; 0x96 <FlashLED>
					LED_Warning = 0;
 a6a:	10 92 75 00 	sts	0x0075, r1
					Delay100ms(5);
 a6e:	85 e0       	ldi	r24, 0x05	; 5
 a70:	90 e0       	ldi	r25, 0x00	; 0
 a72:	03 db       	rcall	.-2554   	; 0x7a <Delay100ms>
					ShowFanSpeedOverride(SetupType ? FanSpeedForce[datapos - 1] : FanSpeedOverrideArray[datapos - 1]);
 a74:	80 91 87 00 	lds	r24, 0x0087
 a78:	e0 91 6a 00 	lds	r30, 0x006A
 a7c:	f0 e0       	ldi	r31, 0x00	; 0
 a7e:	88 23       	and	r24, r24
 a80:	19 f0       	breq	.+6      	; 0xa88 <main+0x44a>
 a82:	e3 57       	subi	r30, 0x73	; 115
 a84:	ff 4f       	sbci	r31, 0xFF	; 255
 a86:	02 c0       	rjmp	.+4      	; 0xa8c <main+0x44e>
 a88:	e5 58       	subi	r30, 0x85	; 133
 a8a:	ff 4f       	sbci	r31, 0xFF	; 255
 a8c:	80 81       	ld	r24, Z
 a8e:	a8 dd       	rcall	.-1200   	; 0x5e0 <ShowFanSpeedOverride>
					Timer = 255; // ~32 sec
 a90:	10 93 61 00 	sts	0x0061, r17
 a94:	56 c0       	rjmp	.+172    	; 0xb42 <main+0x504>
				EEPROM_write(EPROM_OSCCAL, OSCCAL);
				TCCR0A &= ~(1<<COM0B1);
				DDRA &= ~(1<<PORTA7); // in
				continue;
			}
			SetupIR = 0;
 a96:	10 92 6c 00 	sts	0x006C, r1
				if(IRReceived == IRIsCommandReceived) {
					if(SetupIR == 1) EEPROM_write(EPROM_IRCommandHead - 1 + SetupIR, IRHead);
					EEPROM_write(EPROM_IRCommandArray + (SetupIR-1) * sizeof(IRHash), (uint8_t) (IRHash % 256));
					EEPROM_write(EPROM_IRCommandArray + (SetupIR-1) * sizeof(IRHash) + 1, (uint8_t) (IRHash / 256));
					if(SetupIR < IRCommands) {
xSetupIR:				SetupIR++;
 a9a:	80 91 6c 00 	lds	r24, 0x006C
 a9e:	8f 5f       	subi	r24, 0xFF	; 255
 aa0:	80 93 6c 00 	sts	0x006C, r24
						FlashLED(3, 1, 1);
 aa4:	41 e0       	ldi	r20, 0x01	; 1
 aa6:	61 e0       	ldi	r22, 0x01	; 1
 aa8:	83 e0       	ldi	r24, 0x03	; 3
 aaa:	f5 da       	rcall	.-2582   	; 0x96 <FlashLED>
						LED_Warning = SetupIR;
 aac:	80 91 6c 00 	lds	r24, 0x006C
 ab0:	80 93 75 00 	sts	0x0075, r24
						Delay100ms(15);
 ab4:	8f e0       	ldi	r24, 0x0F	; 15
 ab6:	90 e0       	ldi	r25, 0x00	; 0
 ab8:	e0 da       	rcall	.-2624   	; 0x7a <Delay100ms>
						IRReceived = 0;
 aba:	10 92 6e 00 	sts	0x006E, r1
						Timer = 255;
 abe:	10 93 61 00 	sts	0x0061, r17
					} else {
						FlashLED(8, 1, 1);
						break;
					}
				}
			} while(Timer);
 ac2:	80 91 61 00 	lds	r24, 0x0061
 ac6:	88 23       	and	r24, r24
 ac8:	19 f1       	breq	.+70     	; 0xb10 <main+0x4d2>
			}
			SetupIR = 0;
			goto xSetupIR;
			do {
				__asm__ volatile ("" ::: "memory"); // Need memory barrier
				sleep_cpu();
 aca:	88 95       	sleep
				if(IRReceived == IRIsCommandReceived) {
 acc:	80 91 6e 00 	lds	r24, 0x006E
 ad0:	83 30       	cpi	r24, 0x03	; 3
 ad2:	b9 f7       	brne	.-18     	; 0xac2 <main+0x484>
					if(SetupIR == 1) EEPROM_write(EPROM_IRCommandHead - 1 + SetupIR, IRHead);
 ad4:	80 91 6c 00 	lds	r24, 0x006C
 ad8:	81 30       	cpi	r24, 0x01	; 1
 ada:	21 f4       	brne	.+8      	; 0xae4 <main+0x4a6>
 adc:	60 91 77 00 	lds	r22, 0x0077
 ae0:	80 e3       	ldi	r24, 0x30	; 48
 ae2:	fb da       	rcall	.-2570   	; 0xda <EEPROM_write>
					EEPROM_write(EPROM_IRCommandArray + (SetupIR-1) * sizeof(IRHash), (uint8_t) (IRHash % 256));
 ae4:	80 91 6c 00 	lds	r24, 0x006C
 ae8:	88 0f       	add	r24, r24
 aea:	60 91 79 00 	lds	r22, 0x0079
 aee:	81 5d       	subi	r24, 0xD1	; 209
 af0:	f4 da       	rcall	.-2584   	; 0xda <EEPROM_write>
					EEPROM_write(EPROM_IRCommandArray + (SetupIR-1) * sizeof(IRHash) + 1, (uint8_t) (IRHash / 256));
 af2:	60 91 7a 00 	lds	r22, 0x007A
 af6:	80 91 6c 00 	lds	r24, 0x006C
 afa:	88 0f       	add	r24, r24
 afc:	80 5d       	subi	r24, 0xD0	; 208
 afe:	ed da       	rcall	.-2598   	; 0xda <EEPROM_write>
					if(SetupIR < IRCommands) {
 b00:	80 91 6c 00 	lds	r24, 0x006C
 b04:	84 30       	cpi	r24, 0x04	; 4
 b06:	48 f2       	brcs	.-110    	; 0xa9a <main+0x45c>
						LED_Warning = SetupIR;
						Delay100ms(15);
						IRReceived = 0;
						Timer = 255;
					} else {
						FlashLED(8, 1, 1);
 b08:	41 e0       	ldi	r20, 0x01	; 1
 b0a:	61 e0       	ldi	r22, 0x01	; 1
 b0c:	88 e0       	ldi	r24, 0x08	; 8
 b0e:	c3 da       	rcall	.-2682   	; 0x96 <FlashLED>
						break;
					}
				}
			} while(Timer);
			IRReceived = 0;
 b10:	10 92 6e 00 	sts	0x006E, r1
			Key1Pressed = 0;
 b14:	10 92 6d 00 	sts	0x006D, r1
			SetupIR = 0;
 b18:	10 92 6c 00 	sts	0x006C, r1
			LED_Warning = 0;
 b1c:	10 92 75 00 	sts	0x0075, r1
		}
		if(Timer == 0)
 b20:	80 91 61 00 	lds	r24, 0x0061
 b24:	81 11       	cpse	r24, r1
 b26:	ef cd       	rjmp	.-1058   	; 0x706 <main+0xc8>
		{
			uint16_t co2;
			if(Setup) goto xSetupExit;
 b28:	80 91 6b 00 	lds	r24, 0x006B
 b2c:	88 23       	and	r24, r24
 b2e:	09 f4       	brne	.+2      	; 0xb32 <main+0x4f4>
 b30:	5e c0       	rjmp	.+188    	; 0xbee <main+0x5b0>
					LED_Warning = 0;
					Delay100ms(5);
					ShowFanSpeedOverride(SetupType ? FanSpeedForce[datapos - 1] : FanSpeedOverrideArray[datapos - 1]);
					Timer = 255; // ~32 sec
				} else {
xSetupExit:			Setup = 0;
 b32:	10 92 6b 00 	sts	0x006B, r1
					SetupItem = 0;
 b36:	10 92 7b 00 	sts	0x007B, r1
					LED_Warning = 0;
 b3a:	10 92 75 00 	sts	0x0075, r1
					Timer = 0;
 b3e:	10 92 61 00 	sts	0x0061, r1
				}
				break;
			}
		}
		if(KeyOkTimeout == 1) { // Reseting single time Ok pressed
 b42:	80 91 70 00 	lds	r24, 0x0070
 b46:	81 30       	cpi	r24, 0x01	; 1
 b48:	31 f4       	brne	.+12     	; 0xb56 <main+0x518>
			FanSpeedOverride = 0;
 b4a:	10 92 71 00 	sts	0x0071, r1
			FlashLED(5, 1, 1);
 b4e:	41 e0       	ldi	r20, 0x01	; 1
 b50:	61 e0       	ldi	r22, 0x01	; 1
 b52:	85 e0       	ldi	r24, 0x05	; 5
 b54:	a0 da       	rcall	.-2752   	; 0x96 <FlashLED>
		}
		if(Key1Pressed == 255) // Press and hold key1 for ~3.2 sec
 b56:	80 91 6d 00 	lds	r24, 0x006D
 b5a:	8f 3f       	cpi	r24, 0xFF	; 255
 b5c:	09 f7       	brne	.-62     	; 0xb20 <main+0x4e2>
		{	// Setup IR Commands (2 (after 3.2s) and 7 short flashed will indicate it):
			FlashLED(2, 1, 1);
 b5e:	41 e0       	ldi	r20, 0x01	; 1
 b60:	61 e0       	ldi	r22, 0x01	; 1
 b62:	82 e0       	ldi	r24, 0x02	; 2
 b64:	98 da       	rcall	.-2768   	; 0x96 <FlashLED>
			Key1Pressed = 0;
 b66:	10 92 6d 00 	sts	0x006D, r1
			do { Delay100ms(1); } while(KEY1_PRESSING);
 b6a:	81 e0       	ldi	r24, 0x01	; 1
 b6c:	90 e0       	ldi	r25, 0x00	; 0
 b6e:	85 da       	rcall	.-2806   	; 0x7a <Delay100ms>
 b70:	b2 9b       	sbis	0x16, 2	; 22
 b72:	fb cf       	rjmp	.-10     	; 0xb6a <main+0x52c>
			if(Key1Pressed == 255) { // + ~3.2 sec
 b74:	80 91 6d 00 	lds	r24, 0x006D
 b78:	8f 3f       	cpi	r24, 0xFF	; 255
 b7a:	09 f0       	breq	.+2      	; 0xb7e <main+0x540>
 b7c:	8c cf       	rjmp	.-232    	; 0xa96 <main+0x458>
				// Set OSCCAL. Freq out 20480 Hz -> OC0B (pin 6).
				OCR0B = (OCR0A + 1) / 2 - 1; // Half Duty cycle = ((TOP+1)/2-1)
 b7e:	86 b7       	in	r24, 0x36	; 54
 b80:	90 e0       	ldi	r25, 0x00	; 0
 b82:	01 96       	adiw	r24, 0x01	; 1
 b84:	95 95       	asr	r25
 b86:	87 95       	ror	r24
 b88:	81 50       	subi	r24, 0x01	; 1
 b8a:	8c bf       	out	0x3c, r24	; 60
				TCCR0A |= (1<<COM0B1);  // Freq out: pin OC0B
 b8c:	80 b7       	in	r24, 0x30	; 48
 b8e:	80 62       	ori	r24, 0x20	; 32
 b90:	80 bf       	out	0x30, r24	; 48
				DDRA |= (1<<PORTA7); // out
 b92:	d7 9a       	sbi	0x1a, 7	; 26
								FlashLED(1, 1, 1);
							} else {
								OSCCAL--;
								FlashLED(2, 1, 1);
							}
xSetupOSCCAL:				Key1Pressed = 0;
 b94:	10 92 6d 00 	sts	0x006D, r1
							Timer = 255;
 b98:	10 93 61 00 	sts	0x0061, r17
						}
					}
				} while(Timer);
 b9c:	80 91 61 00 	lds	r24, 0x0061
 ba0:	88 23       	and	r24, r24
 ba2:	c9 f0       	breq	.+50     	; 0xbd6 <main+0x598>
				TCCR0A |= (1<<COM0B1);  // Freq out: pin OC0B
				DDRA |= (1<<PORTA7); // out
				goto xSetupOSCCAL;
				do {
					__asm__ volatile ("" ::: "memory"); // Need memory barrier
					LED1_ON;
 ba4:	d9 9a       	sbi	0x1b, 1	; 27
					sleep_cpu();
 ba6:	88 95       	sleep
					if(!KEY1_PRESSING) {
 ba8:	b2 9b       	sbis	0x16, 2	; 22
 baa:	f8 cf       	rjmp	.-16     	; 0xb9c <main+0x55e>
						if(Key1Pressed > 2) {
 bac:	80 91 6d 00 	lds	r24, 0x006D
 bb0:	83 30       	cpi	r24, 0x03	; 3
 bb2:	a0 f3       	brcs	.-24     	; 0xb9c <main+0x55e>
							if(Key1Pressed < 80) { // ~ 1 sec
 bb4:	80 35       	cpi	r24, 0x50	; 80
 bb6:	38 f4       	brcc	.+14     	; 0xbc6 <main+0x588>
								OSCCAL++;
 bb8:	81 b7       	in	r24, 0x31	; 49
 bba:	8f 5f       	subi	r24, 0xFF	; 255
 bbc:	81 bf       	out	0x31, r24	; 49
								FlashLED(1, 1, 1);
 bbe:	41 e0       	ldi	r20, 0x01	; 1
 bc0:	61 e0       	ldi	r22, 0x01	; 1
 bc2:	81 e0       	ldi	r24, 0x01	; 1
 bc4:	06 c0       	rjmp	.+12     	; 0xbd2 <main+0x594>
							} else {
								OSCCAL--;
 bc6:	81 b7       	in	r24, 0x31	; 49
 bc8:	81 50       	subi	r24, 0x01	; 1
 bca:	81 bf       	out	0x31, r24	; 49
								FlashLED(2, 1, 1);
 bcc:	41 e0       	ldi	r20, 0x01	; 1
 bce:	61 e0       	ldi	r22, 0x01	; 1
 bd0:	82 e0       	ldi	r24, 0x02	; 2
 bd2:	61 da       	rcall	.-2878   	; 0x96 <FlashLED>
 bd4:	df cf       	rjmp	.-66     	; 0xb94 <main+0x556>
xSetupOSCCAL:				Key1Pressed = 0;
							Timer = 255;
						}
					}
				} while(Timer);
				FlashLED(7, 1, 1);
 bd6:	41 e0       	ldi	r20, 0x01	; 1
 bd8:	61 e0       	ldi	r22, 0x01	; 1
 bda:	87 e0       	ldi	r24, 0x07	; 7
 bdc:	5c da       	rcall	.-2888   	; 0x96 <FlashLED>
				EEPROM_write(EPROM_OSCCAL, OSCCAL);
 bde:	61 b7       	in	r22, 0x31	; 49
 be0:	80 e0       	ldi	r24, 0x00	; 0
 be2:	7b da       	rcall	.-2826   	; 0xda <EEPROM_write>
				TCCR0A &= ~(1<<COM0B1);
 be4:	80 b7       	in	r24, 0x30	; 48
 be6:	8f 7d       	andi	r24, 0xDF	; 223
 be8:	80 bf       	out	0x30, r24	; 48
				DDRA &= ~(1<<PORTA7); // in
 bea:	d7 98       	cbi	0x1a, 7	; 26
				continue;
 bec:	8c cd       	rjmp	.-1256   	; 0x706 <main+0xc8>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 bee:	f8 94       	cli
		{
			uint16_t co2;
			if(Setup) goto xSetupExit;
xSendNow:
			ATOMIC_BLOCK(ATOMIC_FORCEON) {
				co2 = CO2Level;
 bf0:	c0 91 72 00 	lds	r28, 0x0072
 bf4:	d0 91 73 00 	lds	r29, 0x0073
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
 bf8:	78 94       	sei
			}
			if(CO2LevelAverageCnt == 255) { // first time
 bfa:	80 91 60 00 	lds	r24, 0x0060
 bfe:	8f 3f       	cpi	r24, 0xFF	; 255
 c00:	69 f4       	brne	.+26     	; 0xc1c <main+0x5de>
				for(i = 1; i < CO2LevelAverageArrayLength; i++)
					CO2LevelAverageArray[i] = co2;
 c02:	d0 93 9b 00 	sts	0x009B, r29
 c06:	c0 93 9a 00 	sts	0x009A, r28
 c0a:	d0 93 9d 00 	sts	0x009D, r29
 c0e:	c0 93 9c 00 	sts	0x009C, r28
 c12:	d0 93 9f 00 	sts	0x009F, r29
 c16:	c0 93 9e 00 	sts	0x009E, r28
 c1a:	02 c0       	rjmp	.+4      	; 0xc20 <main+0x5e2>
			}
			if(CO2LevelAverageCnt >= CO2LevelAverageArrayLength) CO2LevelAverageCnt = 0;
 c1c:	84 30       	cpi	r24, 0x04	; 4
 c1e:	10 f0       	brcs	.+4      	; 0xc24 <main+0x5e6>
 c20:	10 92 60 00 	sts	0x0060, r1
			CO2LevelAverageArray[CO2LevelAverageCnt++] = co2;
 c24:	e0 91 60 00 	lds	r30, 0x0060
 c28:	81 e0       	ldi	r24, 0x01	; 1
 c2a:	8e 0f       	add	r24, r30
 c2c:	80 93 60 00 	sts	0x0060, r24
 c30:	f0 e0       	ldi	r31, 0x00	; 0
 c32:	ee 0f       	add	r30, r30
 c34:	ff 1f       	adc	r31, r31
 c36:	e8 56       	subi	r30, 0x68	; 104
 c38:	ff 4f       	sbci	r31, 0xFF	; 255
 c3a:	d1 83       	std	Z+1, r29	; 0x01
 c3c:	c0 83       	st	Z, r28
			uint16_t average = 0;
			for(i = 0; i < CO2LevelAverageArrayLength; i++)
				average += CO2LevelAverageArray[i];
 c3e:	80 91 9a 00 	lds	r24, 0x009A
 c42:	90 91 9b 00 	lds	r25, 0x009B
 c46:	20 91 9c 00 	lds	r18, 0x009C
 c4a:	30 91 9d 00 	lds	r19, 0x009D
 c4e:	82 0f       	add	r24, r18
 c50:	93 1f       	adc	r25, r19
 c52:	20 91 9e 00 	lds	r18, 0x009E
 c56:	30 91 9f 00 	lds	r19, 0x009F
 c5a:	82 0f       	add	r24, r18
 c5c:	93 1f       	adc	r25, r19
 c5e:	20 91 98 00 	lds	r18, 0x0098
 c62:	30 91 99 00 	lds	r19, 0x0099
 c66:	82 0f       	add	r24, r18
 c68:	93 1f       	adc	r25, r19
			uint8_t average1b = (average /= CO2LevelAverageArrayLength) / 16; 
 c6a:	56 e0       	ldi	r21, 0x06	; 6
 c6c:	96 95       	lsr	r25
 c6e:	87 95       	ror	r24
 c70:	5a 95       	dec	r21
 c72:	e1 f7       	brne	.-8      	; 0xc6c <main+0x62e>
 c74:	d8 2e       	mov	r13, r24
			int8_t fanspeed = 0;
 c76:	e1 2c       	mov	r14, r1
			static int8_t fanspeed_prev = 0;
			for(; fanspeed < FanSpeedMax; fanspeed++) {
				uint8_t t = EEPROM_read(EPROM_FanSpeedThreshold + fanspeed);
 c78:	80 e1       	ldi	r24, 0x10	; 16
 c7a:	8e 0d       	add	r24, r14
 c7c:	26 da       	rcall	.-2996   	; 0xca <EEPROM_read>
				if(average1b < t) { 
 c7e:	d8 16       	cp	r13, r24
 c80:	28 f0       	brcs	.+10     	; 0xc8c <main+0x64e>
 c82:	e3 94       	inc	r14
			for(i = 0; i < CO2LevelAverageArrayLength; i++)
				average += CO2LevelAverageArray[i];
			uint8_t average1b = (average /= CO2LevelAverageArrayLength) / 16; 
			int8_t fanspeed = 0;
			static int8_t fanspeed_prev = 0;
			for(; fanspeed < FanSpeedMax; fanspeed++) {
 c84:	86 e0       	ldi	r24, 0x06	; 6
 c86:	e8 12       	cpse	r14, r24
 c88:	f7 cf       	rjmp	.-18     	; 0xc78 <main+0x63a>
 c8a:	0a c0       	rjmp	.+20     	; 0xca0 <main+0x662>
				uint8_t t = EEPROM_read(EPROM_FanSpeedThreshold + fanspeed);
				if(average1b < t) { 
					// if there is a decrease of CO2 level - check delta
					if(fanspeed_prev <= fanspeed || (uint8_t)(t - average1b) >= EEPROM_read(EPROM_FanSpeedDelta)) break; 
 c8c:	90 91 62 00 	lds	r25, 0x0062
 c90:	e9 16       	cp	r14, r25
 c92:	34 f4       	brge	.+12     	; 0xca0 <main+0x662>
 c94:	c8 2e       	mov	r12, r24
 c96:	cd 18       	sub	r12, r13
 c98:	86 e0       	ldi	r24, 0x06	; 6
 c9a:	17 da       	rcall	.-3026   	; 0xca <EEPROM_read>
 c9c:	c8 16       	cp	r12, r24
 c9e:	88 f3       	brcs	.-30     	; 0xc82 <main+0x644>
				}
			}
			fanspeed_prev = fanspeed;
 ca0:	e0 92 62 00 	sts	0x0062, r14
			if((fanspeed += FanSpeedOverride) > FanSpeedMax) fanspeed = FanSpeedMax;
 ca4:	b0 90 71 00 	lds	r11, 0x0071
 ca8:	be 0c       	add	r11, r14
 caa:	96 e0       	ldi	r25, 0x06	; 6
 cac:	9b 15       	cp	r25, r11
 cae:	24 f0       	brlt	.+8      	; 0xcb8 <main+0x67a>
			if(fanspeed < 0) fanspeed = 0;
 cb0:	b7 fe       	sbrs	r11, 7
 cb2:	04 c0       	rjmp	.+8      	; 0xcbc <main+0x67e>
 cb4:	b1 2c       	mov	r11, r1
 cb6:	02 c0       	rjmp	.+4      	; 0xcbc <main+0x67e>
					// if there is a decrease of CO2 level - check delta
					if(fanspeed_prev <= fanspeed || (uint8_t)(t - average1b) >= EEPROM_read(EPROM_FanSpeedDelta)) break; 
				}
			}
			fanspeed_prev = fanspeed;
			if((fanspeed += FanSpeedOverride) > FanSpeedMax) fanspeed = FanSpeedMax;
 cb8:	36 e0       	ldi	r19, 0x06	; 6
 cba:	b3 2e       	mov	r11, r19
			if(fanspeed < 0) fanspeed = 0;
			if(LowLight && fanspeed > (int8_t)(i = EEPROM_read(EPROM_LowLightMaxFanSpeed))) fanspeed = i;
 cbc:	80 91 74 00 	lds	r24, 0x0074
 cc0:	88 23       	and	r24, r24
 cc2:	29 f0       	breq	.+10     	; 0xcce <main+0x690>
 cc4:	84 e0       	ldi	r24, 0x04	; 4
 cc6:	01 da       	rcall	.-3070   	; 0xca <EEPROM_read>
 cc8:	8b 15       	cp	r24, r11
 cca:	0c f4       	brge	.+2      	; 0xcce <main+0x690>
 ccc:	b8 2e       	mov	r11, r24
			//NRF24_SetMode(NRF24_TransmitMode);
			for(uint8_t fan = 0; fan < EEPROM_read(EPROM_NumberFans); fan++)
 cce:	91 2c       	mov	r9, r1
 cd0:	82 e0       	ldi	r24, 0x02	; 2
 cd2:	fb d9       	rcall	.-3082   	; 0xca <EEPROM_read>
 cd4:	98 16       	cp	r9, r24
 cd6:	08 f0       	brcs	.+2      	; 0xcda <main+0x69c>
 cd8:	7f c0       	rjmp	.+254    	; 0xdd8 <main+0x79a>
			{
				uint8_t addr = EEPROM_read(EPROM_RFAddresses + fan);
 cda:	80 e2       	ldi	r24, 0x20	; 32
 cdc:	89 0d       	add	r24, r9
 cde:	f5 d9       	rcall	.-3094   	; 0xca <EEPROM_read>
 ce0:	e8 2e       	mov	r14, r24
				if(rf_last_addr != addr) {
 ce2:	80 91 68 00 	lds	r24, 0x0068
 ce6:	8e 15       	cp	r24, r14
 ce8:	41 f0       	breq	.+16     	; 0xcfa <main+0x6bc>
					if(!NRF24_SetAddresses(addr)) {
 cea:	8e 2d       	mov	r24, r14
 cec:	94 da       	rcall	.-2776   	; 0x216 <NRF24_SetAddresses>
 cee:	81 11       	cpse	r24, r1
 cf0:	02 c0       	rjmp	.+4      	; 0xcf6 <main+0x6b8>
						Set_LED_Warning(ERR_RF_SetAddr);
 cf2:	80 e2       	ldi	r24, 0x20	; 32
 cf4:	6c c0       	rjmp	.+216    	; 0xdce <main+0x790>
						rf_reset_chip();
						break;
					}
					rf_last_addr = addr;
 cf6:	e0 92 68 00 	sts	0x0068, r14
				}
				int8_t fspeed = fanspeed + FanSpeedOverrideArray[fan];
 cfa:	c9 2c       	mov	r12, r9
 cfc:	d1 2c       	mov	r13, r1
 cfe:	f6 01       	movw	r30, r12
 d00:	e4 58       	subi	r30, 0x84	; 132
 d02:	ff 4f       	sbci	r31, 0xFF	; 255
 d04:	a0 80       	ld	r10, Z
 d06:	ab 0c       	add	r10, r11
				if(fspeed > FanSpeedMax) fspeed = FanSpeedMax;
 d08:	86 e0       	ldi	r24, 0x06	; 6
 d0a:	8a 15       	cp	r24, r10
 d0c:	24 f0       	brlt	.+8      	; 0xd16 <main+0x6d8>
				if(fspeed < 0) fspeed = 0;
 d0e:	a7 fe       	sbrs	r10, 7
 d10:	04 c0       	rjmp	.+8      	; 0xd1a <main+0x6dc>
 d12:	a1 2c       	mov	r10, r1
 d14:	02 c0       	rjmp	.+4      	; 0xd1a <main+0x6dc>
						break;
					}
					rf_last_addr = addr;
				}
				int8_t fspeed = fanspeed + FanSpeedOverrideArray[fan];
				if(fspeed > FanSpeedMax) fspeed = FanSpeedMax;
 d16:	26 e0       	ldi	r18, 0x06	; 6
 d18:	a2 2e       	mov	r10, r18
				if(fspeed < 0) fspeed = 0;
				uint8_t RF_Changed = 0;
 d1a:	71 2c       	mov	r7, r1
				i = EPROM_FanSpeedChangeArray;
 d1c:	90 e4       	ldi	r25, 0x40	; 64
 d1e:	e9 2e       	mov	r14, r25
				do {
					uint8_t j = EEPROM_read(i++);
 d20:	88 24       	eor	r8, r8
 d22:	83 94       	inc	r8
 d24:	8e 0c       	add	r8, r14
 d26:	8e 2d       	mov	r24, r14
 d28:	d0 d9       	rcall	.-3168   	; 0xca <EEPROM_read>
					if(j == fan) {
 d2a:	89 11       	cpse	r24, r9
 d2c:	20 c0       	rjmp	.+64     	; 0xd6e <main+0x730>
						if((j = EEPROM_read(i++)) != 0xFF) { // Set RF channel
 d2e:	82 e0       	ldi	r24, 0x02	; 2
 d30:	68 2e       	mov	r6, r24
 d32:	6e 0c       	add	r6, r14
 d34:	88 2d       	mov	r24, r8
 d36:	c9 d9       	rcall	.-3182   	; 0xca <EEPROM_read>
 d38:	68 2f       	mov	r22, r24
 d3a:	8f 3f       	cpi	r24, 0xFF	; 255
 d3c:	21 f0       	breq	.+8      	; 0xd46 <main+0x708>
							NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH,	j);
 d3e:	85 e2       	ldi	r24, 0x25	; 37
 d40:	04 da       	rcall	.-3064   	; 0x14a <NRF24_WriteByte>
							RF_Changed = 1;
 d42:	77 24       	eor	r7, r7
 d44:	73 94       	inc	r7
						}
						for(j = EEPROM_read(i++); j > 0; j--) { // Change speed if needed
 d46:	93 e0       	ldi	r25, 0x03	; 3
 d48:	e9 0e       	add	r14, r25
 d4a:	86 2d       	mov	r24, r6
 d4c:	be d9       	rcall	.-3204   	; 0xca <EEPROM_read>
 d4e:	88 2e       	mov	r8, r24
 d50:	88 20       	and	r8, r8
 d52:	31 f3       	breq	.-52     	; 0xd20 <main+0x6e2>
							if((uint8_t) fspeed == EEPROM_read(i++)) {
 d54:	8e 2d       	mov	r24, r14
 d56:	b9 d9       	rcall	.-3214   	; 0xca <EEPROM_read>
 d58:	a8 12       	cpse	r10, r24
 d5a:	05 c0       	rjmp	.+10     	; 0xd66 <main+0x728>
								fspeed = EEPROM_read(i);
 d5c:	81 e0       	ldi	r24, 0x01	; 1
 d5e:	8e 0d       	add	r24, r14
 d60:	b4 d9       	rcall	.-3224   	; 0xca <EEPROM_read>
 d62:	a8 2e       	mov	r10, r24
								goto xSkipArrayEnd;
 d64:	0f c0       	rjmp	.+30     	; 0xd84 <main+0x746>
							} else i++;
 d66:	e3 94       	inc	r14
 d68:	e3 94       	inc	r14
					if(j == fan) {
						if((j = EEPROM_read(i++)) != 0xFF) { // Set RF channel
							NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH,	j);
							RF_Changed = 1;
						}
						for(j = EEPROM_read(i++); j > 0; j--) { // Change speed if needed
 d6a:	8a 94       	dec	r8
 d6c:	f1 cf       	rjmp	.-30     	; 0xd50 <main+0x712>
							if((uint8_t) fspeed == EEPROM_read(i++)) {
								fspeed = EEPROM_read(i);
								goto xSkipArrayEnd;
							} else i++;
						}
					} else if(j == 0xFF) { 
 d6e:	8f 3f       	cpi	r24, 0xFF	; 255
 d70:	49 f0       	breq	.+18     	; 0xd84 <main+0x746>
						break;
					} else i += EEPROM_read(i + 1) * 2 + 2;
 d72:	82 e0       	ldi	r24, 0x02	; 2
 d74:	8e 0d       	add	r24, r14
 d76:	a9 d9       	rcall	.-3246   	; 0xca <EEPROM_read>
 d78:	e8 2e       	mov	r14, r24
 d7a:	ee 0c       	add	r14, r14
 d7c:	e3 94       	inc	r14
 d7e:	e3 94       	inc	r14
 d80:	e8 0c       	add	r14, r8
 d82:	ce cf       	rjmp	.-100    	; 0xd20 <main+0x6e2>
				} while(1);
xSkipArrayEnd:
				((send_data*) &NRF24_Buffer)->CO2level = co2;
 d84:	d0 93 8a 00 	sts	0x008A, r29
 d88:	c0 93 89 00 	sts	0x0089, r28
				((send_data*) &NRF24_Buffer)->FanSpeed = FanSpeedForce[fan] != -1 ? FanSpeedForce[fan] : fspeed;
 d8c:	f6 01       	movw	r30, r12
 d8e:	e2 57       	subi	r30, 0x72	; 114
 d90:	ff 4f       	sbci	r31, 0xFF	; 255
 d92:	80 81       	ld	r24, Z
 d94:	8f 3f       	cpi	r24, 0xFF	; 255
 d96:	09 f0       	breq	.+2      	; 0xd9a <main+0x75c>
 d98:	a8 2e       	mov	r10, r24
 d9a:	a0 92 8b 00 	sts	0x008B, r10
				((send_data*) &NRF24_Buffer)->Flags = LowLight;
 d9e:	80 91 74 00 	lds	r24, 0x0074
 da2:	80 93 8c 00 	sts	0x008C, r24
				uint8_t err = NRF24_Transmit(NRF24_Buffer);
 da6:	89 e8       	ldi	r24, 0x89	; 137
 da8:	90 e0       	ldi	r25, 0x00	; 0
 daa:	13 da       	rcall	.-3034   	; 0x1d2 <NRF24_Transmit>
 dac:	e8 2e       	mov	r14, r24
				if(RF_Changed) NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH, EEPROM_read(EPROM_RF_Channel)); // restore RF channel
 dae:	77 20       	and	r7, r7
 db0:	29 f0       	breq	.+10     	; 0xdbc <main+0x77e>
 db2:	87 e0       	ldi	r24, 0x07	; 7
 db4:	8a d9       	rcall	.-3308   	; 0xca <EEPROM_read>
 db6:	68 2f       	mov	r22, r24
 db8:	85 e2       	ldi	r24, 0x25	; 37
 dba:	c7 d9       	rcall	.-3186   	; 0x14a <NRF24_WriteByte>
				uint8_t err2 = err == 2 ? ERR_RF_NotResp : (ERR_RF_Send + fan + 1);
 dbc:	82 e0       	ldi	r24, 0x02	; 2
 dbe:	e8 16       	cp	r14, r24
 dc0:	29 f0       	breq	.+10     	; 0xdcc <main+0x78e>
				if(err)	{
 dc2:	ee 20       	and	r14, r14
 dc4:	39 f0       	breq	.+14     	; 0xdd4 <main+0x796>
				((send_data*) &NRF24_Buffer)->CO2level = co2;
				((send_data*) &NRF24_Buffer)->FanSpeed = FanSpeedForce[fan] != -1 ? FanSpeedForce[fan] : fspeed;
				((send_data*) &NRF24_Buffer)->Flags = LowLight;
				uint8_t err = NRF24_Transmit(NRF24_Buffer);
				if(RF_Changed) NRF24_WriteByte(NRF24_CMD_W_REGISTER | NRF24_REG_RF_CH, EEPROM_read(EPROM_RF_Channel)); // restore RF channel
				uint8_t err2 = err == 2 ? ERR_RF_NotResp : (ERR_RF_Send + fan + 1);
 dc6:	81 e1       	ldi	r24, 0x11	; 17
 dc8:	89 0d       	add	r24, r9
 dca:	01 c0       	rjmp	.+2      	; 0xdce <main+0x790>
 dcc:	80 e3       	ldi	r24, 0x30	; 48
				if(err)	{
					Set_LED_Warning(err2);
 dce:	fa db       	rcall	.-2060   	; 0x5c4 <Set_LED_Warning>
					rf_reset_chip();
 dd0:	19 dc       	rcall	.-1998   	; 0x604 <rf_reset_chip>
					break;
 dd2:	02 c0       	rjmp	.+4      	; 0xdd8 <main+0x79a>
			fanspeed_prev = fanspeed;
			if((fanspeed += FanSpeedOverride) > FanSpeedMax) fanspeed = FanSpeedMax;
			if(fanspeed < 0) fanspeed = 0;
			if(LowLight && fanspeed > (int8_t)(i = EEPROM_read(EPROM_LowLightMaxFanSpeed))) fanspeed = i;
			//NRF24_SetMode(NRF24_TransmitMode);
			for(uint8_t fan = 0; fan < EEPROM_read(EPROM_NumberFans); fan++)
 dd4:	93 94       	inc	r9
 dd6:	7c cf       	rjmp	.-264    	; 0xcd0 <main+0x692>
					rf_reset_chip();
					break;
				}
			}
			//NRF24_Powerdown();
			Timer = EEPROM_read(EPROM_TransmitPeriod);
 dd8:	83 e0       	ldi	r24, 0x03	; 3
 dda:	77 d9       	rcall	.-3346   	; 0xca <EEPROM_read>
 ddc:	80 93 61 00 	sts	0x0061, r24
 de0:	92 cc       	rjmp	.-1756   	; 0x706 <main+0xc8>

00000de2 <memcpy_P>:
 de2:	fb 01       	movw	r30, r22
 de4:	dc 01       	movw	r26, r24
 de6:	02 c0       	rjmp	.+4      	; 0xdec <memcpy_P+0xa>
 de8:	05 90       	lpm	r0, Z+
 dea:	0d 92       	st	X+, r0
 dec:	41 50       	subi	r20, 0x01	; 1
 dee:	50 40       	sbci	r21, 0x00	; 0
 df0:	d8 f7       	brcc	.-10     	; 0xde8 <memcpy_P+0x6>
 df2:	08 95       	ret

00000df4 <_exit>:
 df4:	f8 94       	cli

00000df6 <__stop_program>:
 df6:	ff cf       	rjmp	.-2      	; 0xdf6 <__stop_program>
